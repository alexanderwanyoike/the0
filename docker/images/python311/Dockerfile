# Python 3.11 runtime with the0 daemon binary
# Used for Python bot execution in both Docker and K8s modes

# Stage 1: Build the runtime binary
FROM golang:1.24-alpine AS runtime-builder
RUN apk --no-cache add make git
WORKDIR /build
COPY runtime/go.mod runtime/go.sum ./
RUN go mod download
COPY runtime/ .
RUN CGO_ENABLED=0 go build -ldflags="-s -w" -o runtime ./cmd/app

# Stage 2: Final image
FROM python:3.11-slim

# Install common dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Copy runtime binary
COPY --from=runtime-builder /build/runtime /app/runtime
RUN chmod 755 /app/runtime

# Create required directories
RUN mkdir -p /bot /state /var/the0/logs

# Bootstrap script that runs daemon init, daemon sync, then the bot
COPY <<'EOF' /app/bootstrap.sh
#!/bin/bash
set -e

# Run daemon init to download code and state, generate entrypoint
/app/runtime daemon init \
  --bot-id "$BOT_ID" \
  --code-path /bot \
  --state-path /state \
  --code-file "$CODE_FILE" \
  --runtime "$RUNTIME" \
  --entrypoint "$ENTRYPOINT"

# Determine sync flags based on IS_SCHEDULED
SYNC_FLAGS="--bot-id $BOT_ID --state-path /state --logs-path /var/the0/logs"
if [ "$IS_SCHEDULED" = "true" ]; then
  SYNC_FLAGS="$SYNC_FLAGS --watch-done /var/the0/done"
fi

# Start daemon sync in background
/app/runtime daemon sync $SYNC_FLAGS &
SYNC_PID=$!

# Cleanup function for graceful shutdown
cleanup() {
  EXIT_CODE=$?
  if [ "$IS_SCHEDULED" = "true" ]; then
    echo $EXIT_CODE > /var/the0/done
  fi
  # Give sync time to do final upload
  sleep 3
  kill $SYNC_PID 2>/dev/null || true
  wait $SYNC_PID 2>/dev/null || true
  exit $EXIT_CODE
}
trap cleanup EXIT INT TERM

# Run the bot entrypoint (generated by daemon init)
# Don't use exec - we need the trap to fire on exit
cd /bot
/bin/bash /bot/entrypoint.sh
EOF
RUN chmod 755 /app/bootstrap.sh

# Default working directory
WORKDIR /bot

# Run bootstrap which handles daemon init/sync and then the bot
CMD ["/app/bootstrap.sh"]
