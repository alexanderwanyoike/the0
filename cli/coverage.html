
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">the0/cmd/auth.go (0.0%)</option>
				
				<option value="file1">the0/cmd/backtest.go (0.0%)</option>
				
				<option value="file2">the0/cmd/bot.go (0.0%)</option>
				
				<option value="file3">the0/cmd/check_update.go (0.0%)</option>
				
				<option value="file4">the0/cmd/custom_bot.go (0.0%)</option>
				
				<option value="file5">the0/cmd/self_update.go (0.0%)</option>
				
				<option value="file6">the0/internal/api.go (0.0%)</option>
				
				<option value="file7">the0/internal/auth.go (0.0%)</option>
				
				<option value="file8">the0/internal/config.go (0.0%)</option>
				
				<option value="file9">the0/internal/ignore.go (0.0%)</option>
				
				<option value="file10">the0/internal/updater.go (0.0%)</option>
				
				<option value="file11">the0/internal/vendor.go (0.0%)</option>
				
				<option value="file12">the0/internal/version.go (0.0%)</option>
				
				<option value="file13">the0/internal/zip.go (0.0%)</option>
				
				<option value="file14">the0/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cmd

import (
        "fmt"
        "os"

        "github.com/spf13/cobra"
        "the0/internal"
)

func NewAuthCmd() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "auth",
                Short: "Manage API authentication",
                Long:  "Login, logout, and check authentication status",
        }

        cmd.AddCommand(NewLoginCmd())
        cmd.AddCommand(NewStatusCmd())
        cmd.AddCommand(NewLogoutCmd())
        cmd.AddCommand(NewConfigCmd())
        return cmd
}</span>

func NewLoginCmd() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "login",
                Short: "Set or update your API key",
                Long:  "Connect to the0 platform with your API key",
                Run:   authLogin,
        }
}</span>

func NewStatusCmd() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "status",
                Short: "Check if your API key is valid",
                Long:  "Verify your connection to the0 platform",
                Run:   authStatus,
        }
}</span>

func NewLogoutCmd() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "logout",
                Short: "Remove saved API key",
                Long:  "Clear your saved credentials from this device",
                Run:   authLogout,
        }
}</span>

func NewConfigCmd() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "config [api-url]",
                Short: "Configure API endpoint",
                Long: `Configure the API endpoint for the0 CLI.

If no URL is provided, shows the current API endpoint.
The API URL can also be set via THE0_API_URL environment variable.

Examples:
  the0 auth config                           # Show current API URL
  the0 auth config http://localhost:3001     # Set API URL to localhost
  the0 auth config http://the0-api:3001      # Set API URL to Docker service`,
                Run: authConfig,
        }
        return cmd
}</span>

func authLogin(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        fmt.Println("Jacking into the0...")

        auth, err := internal.PromptForNewAPIKey()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Connection failed: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Println("‚úì Access granted - welcome to the0")
        fmt.Println("Ready to deploy trading bots")

        // Test the key
        apiClient := internal.NewAPIClient(internal.GetAPIBaseURL())
        if err := apiClient.TestAPIKey(auth); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚ö†Ô∏è  Auth test failed: %v\n", err)
                fmt.Println("Check your API key and permissions")
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("‚úì Connection verified")
        }</span>
}

func authStatus(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        fmt.Println("Running system diagnostics...")

        auth, err := internal.LoadAuth()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("No access codes detected. Run 'the0 auth login' to jack in")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Connected: %s\n", auth.CreatedAt.Format("2006-01-02 15:04:05"))

        apiClient := internal.NewAPIClient(internal.GetAPIBaseURL())
        if err := apiClient.TestAPIKey(auth); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Connection failed: %v\n", err)
                fmt.Println("Run 'the0 auth login' to reconnect")
                os.Exit(1)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("‚úì Connection active")
        }</span>
}

func authLogout(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        if err := internal.RemoveAuth(); err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        fmt.Println("No credentials found")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Fprintf(os.Stderr, "Failed to clear credentials: %v\n", err)
                        os.Exit(1)
                }</span>
        } else<span class="cov0" title="0"> {
                fmt.Println("‚úì Access codes wiped")
                fmt.Println("Disconnected from the0")
        }</span>
}

func authConfig(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                // Show current API URL
                currentURL := internal.GetAPIBaseURL()
                envURL := os.Getenv("THE0_API_URL")
                
                fmt.Println("Current API Configuration:")
                fmt.Printf("  API URL: %s\n", currentURL)
                
                if envURL != "" </span><span class="cov0" title="0">{
                        fmt.Printf("  Source: THE0_API_URL environment variable\n")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("  Source: Default (http://localhost:3000)\n")
                }</span>
                
                <span class="cov0" title="0">fmt.Println("\nTo change the API URL:")
                fmt.Println("  the0 auth config &lt;new-url&gt;")
                fmt.Println("  export THE0_API_URL=&lt;new-url&gt;")
                return</span>
        }
        
        // Set API URL via environment variable hint
        <span class="cov0" title="0">newURL := args[0]
        fmt.Printf("To set API URL to %s, use one of these methods:\n\n", newURL)
        fmt.Printf("1. Environment variable (recommended):\n")
        fmt.Printf("   export THE0_API_URL=%s\n\n", newURL)
        fmt.Printf("2. For this session only:\n")
        fmt.Printf("   THE0_API_URL=%s the0 &lt;command&gt;\n\n", newURL)
        fmt.Printf("3. Add to your shell profile (~/.bashrc, ~/.zshrc, etc.):\n")
        fmt.Printf("   echo 'export THE0_API_URL=%s' &gt;&gt; ~/.bashrc\n", newURL)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package cmd

import (
        "bufio"
        "encoding/json"
        "fmt"
        "os"
        "strings"
        "time"

        "github.com/fatih/color"
        "github.com/olekukonko/tablewriter"
        "github.com/spf13/cobra"
        "the0/internal"
)

// NewBacktestCmd creates the backtest command group
func NewBacktestCmd() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "backtest",
                Short: "Manage backtests",
                Long:  "üìä Deploy, list, and manage trading bot backtests on the0 platform",
        }

        cmd.AddCommand(NewBacktestDeployCmd())
        cmd.AddCommand(NewBacktestListCmd())
        cmd.AddCommand(NewBacktestDeleteCmd())

        return cmd
}</span>

// NewBacktestDeployCmd creates the backtest deploy command
func NewBacktestDeployCmd() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "deploy &lt;config.json&gt;",
                Short: "Deploy a new backtest",
                Long:  "üöÄ Deploy a new backtest using a JSON configuration file",
                Args:  cobra.ExactArgs(1),
                Run:   deployBacktest,
        }
}</span>

// NewBacktestListCmd creates the backtest list command
func NewBacktestListCmd() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "list",
                Short: "List all backtests",
                Long:  "üìã List all your backtest instances with their status and details",
                Args:  cobra.NoArgs,
                Run:   listBacktests,
        }
}</span>

// NewBacktestDeleteCmd creates the backtest delete command
func NewBacktestDeleteCmd() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "delete &lt;backtest-id&gt;",
                Short: "Delete a backtest",
                Long:  "üóëÔ∏è  Delete a backtest instance (requires confirmation)",
                Args:  cobra.ExactArgs(1),
                Run:   deleteBacktest,
        }
}</span>

func deployBacktest(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        green := color.New(color.FgGreen)
        red := color.New(color.FgRed)
        blue := color.New(color.FgBlue)

        configPath := args[0]

        blue.Println("üìä Analyzing market data with backtest configuration...")
        fmt.Printf("Config: %s\n", configPath)

        // Load and validate configuration
        configData, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                red.Fprintf(os.Stderr, "‚ùå Error reading config file: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">var config map[string]any
        if err := json.Unmarshal(configData, &amp;config); err != nil </span><span class="cov0" title="0">{
                red.Fprintf(os.Stderr, "‚ùå Invalid JSON in config file: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">green.Println("‚úì Config loaded")

        // Validate required fields
        if config["name"] == nil </span><span class="cov0" title="0">{
                red.Fprintf(os.Stderr, "‚ùå Missing required field: name\n")
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">if config["type"] == nil </span><span class="cov0" title="0">{
                red.Fprintf(os.Stderr, "‚ùå Missing required field: type\n")
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">if config["version"] == nil </span><span class="cov0" title="0">{
                red.Fprintf(os.Stderr, "‚ùå Missing required field: version\n")
                os.Exit(1)
        }</span>

        // Extract backtest name from config
        <span class="cov0" title="0">backtestName := config["name"].(string)
        fmt.Printf("Backtest: %s\n", backtestName)

        // Get authentication
        auth, err := internal.GetAuthTokenWithRetry()
        if err != nil </span><span class="cov0" title="0">{
                red.Fprintf(os.Stderr, "‚ùå Authentication failed: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">green.Println("‚úì Authenticated")

        // Create API client and deploy backtest
        apiClient := internal.NewAPIClient(internal.GetAPIBaseURL())
        request := &amp;internal.BacktestDeployRequest{
                Name:   backtestName,
                Config: config,
        }

        backtest, err := apiClient.CreateBacktest(auth, request)
        if err != nil </span><span class="cov0" title="0">{
                if internal.IsAuthError(err) </span><span class="cov0" title="0">{
                        blue.Println("üîë Access denied. Reconnecting to the grid...")
                        auth, err = internal.PromptForNewAPIKey()
                        if err != nil </span><span class="cov0" title="0">{
                                red.Fprintf(os.Stderr, "‚ùå Failed to get new API key: %v\n", err)
                                os.Exit(1)
                        }</span>
                        // Retry with new auth
                        <span class="cov0" title="0">backtest, err = apiClient.CreateBacktest(auth, request)
                        if err != nil </span><span class="cov0" title="0">{
                                red.Fprintf(os.Stderr, "‚ùå Failed to deploy backtest: %v\n", err)
                                os.Exit(1)
                        }</span>
                } else<span class="cov0" title="0"> {
                        red.Fprintf(os.Stderr, "‚ùå Failed to deploy backtest: %v\n", err)
                        os.Exit(1)
                }</span>
        }

        <span class="cov0" title="0">green.Println("‚úÖ Backtest deployed to the0 üìä")
        fmt.Printf("ID: %s\n", backtest.ID)
        fmt.Printf("Name: %s\n", backtest.Name)
        fmt.Printf("Status: %s\n", backtest.Status)
        blue.Printf("üìù Use 'the0 backtest list' to monitor progress\n")</span>
}

func listBacktests(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        green := color.New(color.FgGreen)
        red := color.New(color.FgRed)
        blue := color.New(color.FgBlue)

        blue.Println("üìä Scanning the grid for backtest results...")

        // Get authentication
        auth, err := internal.GetAuthTokenWithRetry()
        if err != nil </span><span class="cov0" title="0">{
                red.Fprintf(os.Stderr, "‚ùå Authentication failed: %v\n", err)
                os.Exit(1)
        }</span>

        // Create API client and list backtests
        <span class="cov0" title="0">apiClient := internal.NewAPIClient(internal.GetAPIBaseURL())

        backtests, err := apiClient.ListBacktests(auth)
        if err != nil </span><span class="cov0" title="0">{
                if internal.IsAuthError(err) </span><span class="cov0" title="0">{
                        blue.Println("üîë Access denied. Reconnecting to the grid...")
                        auth, err = internal.PromptForNewAPIKey()
                        if err != nil </span><span class="cov0" title="0">{
                                red.Fprintf(os.Stderr, "‚ùå Failed to get new API key: %v\n", err)
                                os.Exit(1)
                        }</span>
                        // Retry with new auth
                        <span class="cov0" title="0">backtests, err = apiClient.ListBacktests(auth)
                        if err != nil </span><span class="cov0" title="0">{
                                red.Fprintf(os.Stderr, "‚ùå Failed to list backtests: %v\n", err)
                                os.Exit(1)
                        }</span>
                } else<span class="cov0" title="0"> {
                        red.Fprintf(os.Stderr, "‚ùå Failed to list backtests: %v\n", err)
                        os.Exit(1)
                }</span>
        }

        <span class="cov0" title="0">if len(backtests) == 0 </span><span class="cov0" title="0">{
                blue.Println("üìä No backtests found. Deploy your first backtest with:")
                blue.Println("   the0 backtest deploy &lt;config.json&gt;")
                return
        }</span>

        <span class="cov0" title="0">green.Printf("üìä Found %d backtest(s):\n\n", len(backtests))

        // Create table
        table := tablewriter.NewWriter(os.Stdout)
        table.Header("ID", "Name", "Status", "Progress", "Created At", "Updated At")

        for _, backtest := range backtests </span><span class="cov0" title="0">{
                status := formatBacktestStatus(backtest.Status)
                progress := formatProgress(backtest.Progress)

                // Convert ISO timestamps to readable dates
                createdTime, err := time.Parse(time.RFC3339, backtest.CreatedAt)
                var createdStr string
                if err != nil </span><span class="cov0" title="0">{
                        createdStr = backtest.CreatedAt[:10] // fallback to simple truncation
                }</span> else<span class="cov0" title="0"> {
                        createdStr = createdTime.Format("2006-01-02 15:04")
                }</span>

                <span class="cov0" title="0">updatedTime, err := time.Parse(time.RFC3339, backtest.UpdatedAt)
                var updatedStr string
                if err != nil </span><span class="cov0" title="0">{
                        updatedStr = backtest.UpdatedAt[:10] // fallback to simple truncation
                }</span> else<span class="cov0" title="0"> {
                        updatedStr = updatedTime.Format("2006-01-02 15:04")
                }</span>

                <span class="cov0" title="0">table.Append(truncateID(backtest.ID), backtest.Name, status, progress, createdStr, updatedStr)</span>
        }

        <span class="cov0" title="0">if err := table.Render(); err != nil </span><span class="cov0" title="0">{
                red.Fprintf(os.Stderr, "Failed to render table: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">green.Println("\nüìà Backtest analysis complete. Ready to optimize your strategy!")</span>
}

func deleteBacktest(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        green := color.New(color.FgGreen)
        red := color.New(color.FgRed)
        blue := color.New(color.FgBlue)
        yellow := color.New(color.FgYellow)

        backtestID := args[0]

        yellow.Printf("‚ö†Ô∏è  Are you sure you want to delete backtest '%s'?\n", backtestID)
        yellow.Println("This action cannot be undone")
        fmt.Print("Type 'yes' to confirm: ")

        reader := bufio.NewReader(os.Stdin)
        confirmation, err := reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                red.Fprintf(os.Stderr, "Failed to read confirmation: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">confirmation = strings.TrimSpace(strings.ToLower(confirmation))
        if confirmation != "yes" </span><span class="cov0" title="0">{
                blue.Println("üìä Deletion cancelled. Backtest data remains safe")
                return
        }</span>

        <span class="cov0" title="0">blue.Println("üóëÔ∏è Starting backtest deletion process...")

        // Get authentication
        auth, err := internal.GetAuthTokenWithRetry()
        if err != nil </span><span class="cov0" title="0">{
                red.Fprintf(os.Stderr, "‚ùå Authentication failed: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">green.Println("‚úì Connected to the0")

        // Delete backtest
        apiClient := internal.NewAPIClient(internal.GetAPIBaseURL())
        err = apiClient.DeleteBacktest(auth, backtestID)
        if err != nil </span><span class="cov0" title="0">{
                if internal.IsAuthError(err) </span><span class="cov0" title="0">{
                        blue.Println("üîë Access denied. Reconnecting to the grid...")
                        auth, err = internal.PromptForNewAPIKey()
                        if err != nil </span><span class="cov0" title="0">{
                                red.Fprintf(os.Stderr, "‚ùå Failed to get new API key: %v\n", err)
                                os.Exit(1)
                        }</span>
                        // Retry with new auth
                        <span class="cov0" title="0">err = apiClient.DeleteBacktest(auth, backtestID)
                        if err != nil </span><span class="cov0" title="0">{
                                red.Fprintf(os.Stderr, "‚ùå Failed to delete backtest: %v\n", err)
                                os.Exit(1)
                        }</span>
                } else<span class="cov0" title="0"> {
                        red.Fprintf(os.Stderr, "‚ùå Failed to delete backtest: %v\n", err)
                        os.Exit(1)
                }</span>
        }

        <span class="cov0" title="0">green.Printf("‚úÖ Backtest '%s' deleted successfully üóëÔ∏è\n", backtestID)</span>
}

// Helper functions
func formatBacktestStatus(status string) string <span class="cov0" title="0">{
        switch strings.ToLower(status) </span>{
        case "pending":<span class="cov0" title="0">
                return "‚è≥ Pending"</span>
        case "running":<span class="cov0" title="0">
                return "üîÑ Running"</span>
        case "completed":<span class="cov0" title="0">
                return "‚úÖ Completed"</span>
        case "failed":<span class="cov0" title="0">
                return "‚ùå Failed"</span>
        default:<span class="cov0" title="0">
                return "‚ùì Unknown"</span>
        }
}

func formatProgress(progress float64) string <span class="cov0" title="0">{
        if progress == 0 </span><span class="cov0" title="0">{
                return "-"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%.1f%%", progress*100)</span>
}

func truncateID(id string) string <span class="cov0" title="0">{
        if len(id) &lt;= 8 </span><span class="cov0" title="0">{
                return id
        }</span>
        <span class="cov0" title="0">return id[:8] + "..."</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">package cmd

import (
        "bufio"
        "encoding/json"
        "fmt"
        "os"
        "os/signal"
        "regexp"
        "strings"
        "syscall"
        "time"

        "github.com/fatih/color"
        "github.com/olekukonko/tablewriter"
        "github.com/spf13/cobra"
        "the0/internal"
)

func NewBotCmd() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "bot",
                Short: "Manage your bot instances",
                Long:  "Deploy, list, update, and delete your trading bots on the0 platform",
        }

        cmd.AddCommand(NewBotDeployCmd())
        cmd.AddCommand(NewBotListCmd())
        cmd.AddCommand(NewBotUpdateCmd())
        cmd.AddCommand(NewBotDeleteCmd())
        cmd.AddCommand(NewBotLogsCmd())
        return cmd
}</span>

func NewBotDeployCmd() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "deploy &lt;config.json&gt;",
                Short: "Deploy a new bot instance",
                Long:  "Deploy a new trading bot to the0 platform",
                Args:  cobra.ExactArgs(1),
                Run:   deployBotInstance,
        }
}</span>

func NewBotListCmd() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "list",
                Short: "List all deployed bot instances",
                Long:  "List all your deployed trading bots with their details",
                Run:   listBotInstances,
        }
}</span>

func NewBotUpdateCmd() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "update &lt;bot_id&gt; &lt;config.json&gt;",
                Short: "Update an existing bot instance",
                Long:  "Update the configuration of an existing bot",
                Args:  cobra.ExactArgs(2),
                Run:   updateBotInstance,
        }
}</span>

func NewBotDeleteCmd() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "delete &lt;bot_id&gt;",
                Short: "Delete a bot instance",
                Long:  "Delete a deployed bot (requires confirmation)",
                Args:  cobra.ExactArgs(1),
                Run:   deleteBotInstance,
        }
}</span>

func NewBotLogsCmd() *cobra.Command <span class="cov0" title="0">{
        var watchMode bool
        var limit int

        cmd := &amp;cobra.Command{
                Use:   "logs &lt;bot_id&gt; [date|dateRange]",
                Short: "View bot logs",
                Long:  "View logs for a deployed bot with optional date filtering",
                Args:  cobra.RangeArgs(1, 2),
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        getBotLogs(cmd, args, watchMode, limit)
                }</span>,
        }

        <span class="cov0" title="0">cmd.Flags().BoolVarP(&amp;watchMode, "watch", "w", false, "Watch logs in real-time (polls every 5 seconds)")
        cmd.Flags().IntVar(&amp;limit, "limit", 100, "Maximum number of log entries to return (max 1000)")

        return cmd</span>
}

func deployBotInstance(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        green := color.New(color.FgGreen)
        red := color.New(color.FgRed)
        blue := color.New(color.FgBlue)

        configPath := args[0]

        blue.Println("Injecting bot into the trading grid...")
        fmt.Printf("Config: %s\n", configPath)

        // Load and parse config.json
        configData, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                red.Fprintf(os.Stderr, "Failed to read config file: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">var config map[string]interface{}
        if err := json.Unmarshal(configData, &amp;config); err != nil </span><span class="cov0" title="0">{
                red.Fprintf(os.Stderr, "Invalid JSON in config file: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">green.Println("‚úì Config loaded")

        // Extract bot name from config
        var botName string
        if nameVal, ok := config["name"].(string); ok </span><span class="cov0" title="0">{
                botName = nameVal
        }</span> else<span class="cov0" title="0"> {
                red.Fprintf(os.Stderr, "Bot name not found in config file. Please add a 'name' field to your config.json\n")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Bot: %s\n", botName)

        // Get auth token
        auth, err := internal.GetAuthTokenWithRetry()
        if err != nil </span><span class="cov0" title="0">{
                red.Fprintf(os.Stderr, "Authentication failed: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">green.Println("‚úì Authenticated")

        // Deploy bot
        apiClient := internal.NewAPIClient(internal.GetAPIBaseURL())
        request := &amp;internal.BotDeployRequest{
                Name:   botName,
                Config: config,
        }

        bot, err := apiClient.DeployBotInstance(auth, request)
        if err != nil </span><span class="cov0" title="0">{
                // Retry with new auth if needed
                if internal.IsAuthError(err) </span><span class="cov0" title="0">{
                        blue.Println("Access denied. Reconnecting to the grid...")
                        auth, err = internal.PromptForNewAPIKey()
                        if err != nil </span><span class="cov0" title="0">{
                                red.Fprintf(os.Stderr, "Authentication failed: %v\n", err)
                                os.Exit(1)
                        }</span>

                        // Retry deployment
                        <span class="cov0" title="0">bot, err = apiClient.DeployBotInstance(auth, request)
                        if err != nil </span><span class="cov0" title="0">{
                                red.Fprintf(os.Stderr, "Deployment failed: %v\n", err)
                                os.Exit(1)
                        }</span>
                } else<span class="cov0" title="0"> {
                        red.Fprintf(os.Stderr, "Deployment failed: %v\n", err)
                        os.Exit(1)
                }</span>
        }

        <span class="cov0" title="0">green.Println("Bot deployed to the0 ‚ö°")
        fmt.Printf("ID: %s\n", bot.ID)
        fmt.Printf("Name: %s\n", bot.Name)
        green.Println("Ready to trade üìà")</span>
}

func listBotInstances(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        green := color.New(color.FgGreen)
        red := color.New(color.FgRed)
        blue := color.New(color.FgBlue)

        blue.Println("Scanning the grid for active bots...")

        // Get auth token
        auth, err := internal.GetAuthTokenWithRetry()
        if err != nil </span><span class="cov0" title="0">{
                red.Fprintf(os.Stderr, "Authentication failed: %v\n", err)
                os.Exit(1)
        }</span>

        // List bots
        <span class="cov0" title="0">apiClient := internal.NewAPIClient(internal.GetAPIBaseURL())
        bots, err := apiClient.ListBots(auth)
        if err != nil </span><span class="cov0" title="0">{
                // Retry with new auth if needed
                if internal.IsAuthError(err) </span><span class="cov0" title="0">{
                        blue.Println("Access denied. Reconnecting to the grid...")
                        auth, err = internal.PromptForNewAPIKey()
                        if err != nil </span><span class="cov0" title="0">{
                                red.Fprintf(os.Stderr, "Authentication failed: %v\n", err)
                                os.Exit(1)
                        }</span>

                        // Retry listing
                        <span class="cov0" title="0">bots, err = apiClient.ListBots(auth)
                        if err != nil </span><span class="cov0" title="0">{
                                red.Fprintf(os.Stderr, "Scan failed: %v\n", err)
                                os.Exit(1)
                        }</span>
                } else<span class="cov0" title="0"> {
                        red.Fprintf(os.Stderr, "Scan failed: %v\n", err)
                        os.Exit(1)
                }</span>
        }

        <span class="cov0" title="0">if len(bots) == 0 </span><span class="cov0" title="0">{
                blue.Println("No bots in the grid. Time to deploy your first trading bot ü§ñ")
                return
        }</span>

        // Create table
        <span class="cov0" title="0">table := tablewriter.NewWriter(os.Stdout)
        table.Header("ID", "Name", "Type", "Version", "Schedule", "Created At", "Updated At")

        for _, bot := range bots </span><span class="cov0" title="0">{
                // Extract type and version from config
                botType := "N/A"
                botVersion := "N/A"
                schedule := "N/A"

                if bot.Config != nil </span><span class="cov0" title="0">{
                        if typeVal, ok := bot.Config["type"].(string); ok </span><span class="cov0" title="0">{
                                botType = typeVal
                        }</span>
                        <span class="cov0" title="0">if versionVal, ok := bot.Config["version"].(string); ok </span><span class="cov0" title="0">{
                                botVersion = versionVal
                        }</span>
                        <span class="cov0" title="0">if scheduleVal, ok := bot.Config["schedule"].(string); ok </span><span class="cov0" title="0">{
                                schedule = scheduleVal
                        }</span>
                }

                // Convert ISO timestamps to readable dates
                <span class="cov0" title="0">createdTime, err := time.Parse(time.RFC3339, bot.CreatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        createdTime = time.Now() // fallback
                }</span>
                <span class="cov0" title="0">createdStr := createdTime.Format("2006-01-02 15:04")

                updatedTime, err := time.Parse(time.RFC3339, bot.UpdatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        updatedTime = time.Now() // fallback
                }</span>
                <span class="cov0" title="0">updatedStr := updatedTime.Format("2006-01-02 15:04")

                table.Append(bot.ID, bot.Name, botType, botVersion, schedule, createdStr, updatedStr)</span>
        }

        <span class="cov0" title="0">green.Printf("Found %d active bot(s) ‚ö°\n\n", len(bots))
        if err := table.Render(); err != nil </span><span class="cov0" title="0">{
                red.Fprintf(os.Stderr, "Failed to render table: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">green.Println("\nBots locked and loaded. Ready to dominate the markets üìà")</span>
}

func updateBotInstance(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        green := color.New(color.FgGreen)
        red := color.New(color.FgRed)
        blue := color.New(color.FgBlue)

        botID := args[0]
        configPath := args[1]

        blue.Println("Updating bot...")
        fmt.Printf("Bot ID: %s\n", botID)
        fmt.Printf("Config: %s\n", configPath)

        // Load and parse config.json
        configData, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                red.Fprintf(os.Stderr, "Failed to read config file: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">var configMap map[string]interface{}
        if err := json.Unmarshal(configData, &amp;configMap); err != nil </span><span class="cov0" title="0">{
                red.Fprintf(os.Stderr, "Invalid JSON in config file: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">green.Println("‚úì Config loaded")

        // Get auth token
        auth, err := internal.GetAuthTokenWithRetry()
        if err != nil </span><span class="cov0" title="0">{
                red.Fprintf(os.Stderr, "Authentication failed: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">green.Println("‚úì Connected to the0")

        // Extract name from config (optional)
        var botName string
        if nameVal, ok := configMap["name"].(string); ok </span><span class="cov0" title="0">{
                botName = nameVal
        }</span>

        // Update bot
        <span class="cov0" title="0">apiClient := internal.NewAPIClient(internal.GetAPIBaseURL())
        request := &amp;internal.BotUpdateRequest{
                Name:   botName,
                Config: configMap,
        }

        err = apiClient.UpdateBotInstance(auth, botID, request)
        if err != nil </span><span class="cov0" title="0">{
                // Retry with new auth if needed
                if internal.IsAuthError(err) </span><span class="cov0" title="0">{
                        blue.Println("Access denied. Reconnecting to the grid...")
                        auth, err = internal.PromptForNewAPIKey()
                        if err != nil </span><span class="cov0" title="0">{
                                red.Fprintf(os.Stderr, "Authentication failed: %v\n", err)
                                os.Exit(1)
                        }</span>

                        // Retry update
                        <span class="cov0" title="0">err = apiClient.UpdateBotInstance(auth, botID, request)
                        if err != nil </span><span class="cov0" title="0">{
                                red.Fprintf(os.Stderr, "Update failed: %v\n", err)
                                os.Exit(1)
                        }</span>
                } else<span class="cov0" title="0"> {
                        red.Fprintf(os.Stderr, "Update failed: %v\n", err)
                        os.Exit(1)
                }</span>
        }

        <span class="cov0" title="0">green.Println("Bot updated ‚ö°")
        fmt.Printf("Bot ID: %s\n", botID)
        green.Println("Bot configuration updated and active")</span>
}

func deleteBotInstance(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        green := color.New(color.FgGreen)
        red := color.New(color.FgRed)
        blue := color.New(color.FgBlue)
        yellow := color.New(color.FgYellow)

        botID := args[0]

        yellow.Printf("‚ö†Ô∏è Are you sure you want to delete bot '%s'?\n", botID)
        yellow.Println("This action cannot be undone")
        fmt.Print("Type 'yes' to confirm: ")

        reader := bufio.NewReader(os.Stdin)
        confirmation, err := reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                red.Fprintf(os.Stderr, "Failed to read confirmation: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">confirmation = strings.TrimSpace(strings.ToLower(confirmation))
        if confirmation != "yes" </span><span class="cov0" title="0">{
                blue.Println("Deletion cancelled. Bot remains active üìà")
                return
        }</span>

        <span class="cov0" title="0">blue.Println("üóëÔ∏è Starting bot deletion process...")

        // Get auth token
        auth, err := internal.GetAuthTokenWithRetry()
        if err != nil </span><span class="cov0" title="0">{
                red.Fprintf(os.Stderr, "Authentication failed: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">green.Println("‚úì Connected to the0")

        // Delete bot
        apiClient := internal.NewAPIClient(internal.GetAPIBaseURL())
        err = apiClient.DeleteBotInstance(auth, botID)
        if err != nil </span><span class="cov0" title="0">{
                // Retry with new auth if needed
                if internal.IsAuthError(err) </span><span class="cov0" title="0">{
                        blue.Println("Access denied. Reconnecting to the grid...")
                        auth, err = internal.PromptForNewAPIKey()
                        if err != nil </span><span class="cov0" title="0">{
                                red.Fprintf(os.Stderr, "Authentication failed: %v\n", err)
                                os.Exit(1)
                        }</span>

                        // Retry deletion
                        <span class="cov0" title="0">err = apiClient.DeleteBotInstance(auth, botID)
                        if err != nil </span><span class="cov0" title="0">{
                                red.Fprintf(os.Stderr, "Deletion failed: %v\n", err)
                                os.Exit(1)
                        }</span>
                } else<span class="cov0" title="0"> {
                        red.Fprintf(os.Stderr, "Deletion failed: %v\n", err)
                        os.Exit(1)
                }</span>
        }

        <span class="cov0" title="0">green.Println("Bot terminated üíÄ")
        fmt.Printf("Bot ID: %s\n", botID)
        green.Println("Bot purged from the grid")</span>
}

func getBotLogs(cmd *cobra.Command, args []string, watchMode bool, limit int) <span class="cov0" title="0">{
        red := color.New(color.FgRed)
        blue := color.New(color.FgBlue)
        yellow := color.New(color.FgYellow)

        botID := args[0]
        var dateParam string

        // Parse date/dateRange parameter
        if len(args) &gt; 1 </span><span class="cov0" title="0">{
                dateParam = args[1]
                if err := validateDateParam(dateParam); err != nil </span><span class="cov0" title="0">{
                        red.Fprintf(os.Stderr, "Invalid date format: %v\n", err)
                        os.Exit(1)
                }</span>
        } else<span class="cov0" title="0"> {
                // Default to current date
                dateParam = time.Now().Format("20060102")
        }</span>

        // Validate limit
        <span class="cov0" title="0">if limit &lt; 1 || limit &gt; 1000 </span><span class="cov0" title="0">{
                red.Fprintf(os.Stderr, "Limit must be between 1 and 1000\n")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">blue.Printf("‚ö° Accessing bot logs from the grid: %s\n", botID)
        if watchMode </span><span class="cov0" title="0">{
                yellow.Println("üëÅÔ∏è Watch mode active - monitoring live log stream (press Ctrl+C to stop)")
        }</span>

        // Get auth token
        <span class="cov0" title="0">auth, err := internal.GetAuthTokenWithRetry()
        if err != nil </span><span class="cov0" title="0">{
                red.Fprintf(os.Stderr, "Authentication failed: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">apiClient := internal.NewAPIClient(internal.GetAPIBaseURL())

        if watchMode </span><span class="cov0" title="0">{
                watchBotLogs(apiClient, auth, botID, dateParam, limit)
        }</span> else<span class="cov0" title="0"> {
                displayBotLogs(apiClient, auth, botID, dateParam, limit)
        }</span>
}

func validateDateParam(dateParam string) error <span class="cov0" title="0">{
        // Check for date format (YYYYMMDD)
        dateRegex := regexp.MustCompile(`^\d{8}$`)
        if dateRegex.MatchString(dateParam) </span><span class="cov0" title="0">{
                // Validate it's a real date
                _, err := time.Parse("20060102", dateParam)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid date: %s (use YYYYMMDD format)", dateParam)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Check for date range format (YYYYMMDD-YYYYMMDD)
        <span class="cov0" title="0">dateRangeRegex := regexp.MustCompile(`^\d{8}-\d{8}$`)
        if dateRangeRegex.MatchString(dateParam) </span><span class="cov0" title="0">{
                parts := strings.Split(dateParam, "-")
                startDate, err := time.Parse("20060102", parts[0])
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid start date: %s (use YYYYMMDD format)", parts[0])
                }</span>
                <span class="cov0" title="0">endDate, err := time.Parse("20060102", parts[1])
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid end date: %s (use YYYYMMDD format)", parts[1])
                }</span>
                <span class="cov0" title="0">if startDate.After(endDate) </span><span class="cov0" title="0">{
                        return fmt.Errorf("start date cannot be after end date")
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("invalid format: %s (use YYYYMMDD or YYYYMMDD-YYYYMMDD)", dateParam)</span>
}

func displayBotLogs(apiClient *internal.APIClient, auth *internal.Auth, botID, dateParam string, limit int) <span class="cov0" title="0">{
        green := color.New(color.FgGreen)
        red := color.New(color.FgRed)

        // Build parameters
        params := &amp;internal.LogsParams{
                Limit: limit,
        }

        if strings.Contains(dateParam, "-") </span><span class="cov0" title="0">{
                params.DateRange = dateParam
        }</span> else<span class="cov0" title="0"> {
                params.Date = dateParam
        }</span>

        // Fetch logs
        <span class="cov0" title="0">logs, err := apiClient.GetBotLogs(auth, botID, params)
        if err != nil </span><span class="cov0" title="0">{
                // Retry with new auth if needed
                if internal.IsAuthError(err) </span><span class="cov0" title="0">{
                        blue := color.New(color.FgBlue)
                        blue.Println("Access denied. Reconnecting to the grid...")
                        auth, err = internal.PromptForNewAPIKey()
                        if err != nil </span><span class="cov0" title="0">{
                                red.Fprintf(os.Stderr, "Authentication failed: %v\n", err)
                                os.Exit(1)
                        }</span>

                        // Retry fetching logs
                        <span class="cov0" title="0">logs, err = apiClient.GetBotLogs(auth, botID, params)
                        if err != nil </span><span class="cov0" title="0">{
                                red.Fprintf(os.Stderr, "Failed to fetch logs: %v\n", err)
                                os.Exit(1)
                        }</span>
                } else<span class="cov0" title="0"> {
                        red.Fprintf(os.Stderr, "Failed to fetch logs: %v\n", err)
                        os.Exit(1)
                }</span>
        }

        <span class="cov0" title="0">if len(logs) == 0 </span><span class="cov0" title="0">{
                blue := color.New(color.FgBlue)
                blue.Println("üîç No logs found in the grid for the specified criteria")
                return
        }</span>

        // Display logs
        <span class="cov0" title="0">displayLogEntries(logs)
        green.Printf("\n‚úì Bot log entries retrieved from the grid: %d\n", len(logs))</span>
}

func watchBotLogs(apiClient *internal.APIClient, auth *internal.Auth, botID, dateParam string, limit int) <span class="cov0" title="0">{
        red := color.New(color.FgRed)
        yellow := color.New(color.FgYellow)

        // Set up signal handling for graceful shutdown
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

        // Keep track of last seen timestamp to avoid duplicates
        var lastTimestamp int64 = 0

        ticker := time.NewTicker(1 * time.Second)
        defer ticker.Stop()

        // Initial fetch
        params := &amp;internal.LogsParams{
                Limit: limit,
        }

        if strings.Contains(dateParam, "-") </span><span class="cov0" title="0">{
                params.DateRange = dateParam
        }</span> else<span class="cov0" title="0"> {
                params.Date = dateParam
        }</span>

        // Fetch initial logs
        <span class="cov0" title="0">logs, err := fetchLogsWithRetry(apiClient, auth, botID, params)
        if err != nil </span><span class="cov0" title="0">{
                red.Fprintf(os.Stderr, "Failed to fetch logs: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if len(logs) &gt; 0 </span><span class="cov0" title="0">{
                displayLogEntries(logs)
                // Update last timestamp
                for _, log := range logs </span><span class="cov0" title="0">{
                        if logTime, err := time.Parse(time.RFC3339, log.Date); err == nil </span><span class="cov0" title="0">{
                                if logTime.Unix() &gt; lastTimestamp </span><span class="cov0" title="0">{
                                        lastTimestamp = logTime.Unix()
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">yellow.Println("\n‚ö° Live log monitoring active - streaming from the grid... (press Ctrl+C to disconnect)")

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-sigChan:<span class="cov0" title="0">
                        yellow.Println("\nüîå Stopping live log stream monitor...")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        // Fetch new logs since last timestamp
                        newLogs, err := fetchLogsWithRetry(apiClient, auth, botID, params)
                        if err != nil </span><span class="cov0" title="0">{
                                red.Printf("Error fetching logs: %v\n", err)
                                continue</span>
                        }

                        // Filter out logs we've already seen
                        <span class="cov0" title="0">var unseenLogs []internal.LogEntry
                        for _, log := range newLogs </span><span class="cov0" title="0">{
                                if logTime, err := time.Parse(time.RFC3339, log.Date); err == nil </span><span class="cov0" title="0">{
                                        if logTime.Unix() &gt; lastTimestamp </span><span class="cov0" title="0">{
                                                unseenLogs = append(unseenLogs, log)
                                        }</span>
                                }
                        }

                        <span class="cov0" title="0">if len(unseenLogs) &gt; 0 </span><span class="cov0" title="0">{
                                displayLogEntries(unseenLogs)
                                // Update last timestamp
                                for _, log := range unseenLogs </span><span class="cov0" title="0">{
                                        if logTime, err := time.Parse(time.RFC3339, log.Date); err == nil </span><span class="cov0" title="0">{
                                                if logTime.Unix() &gt; lastTimestamp </span><span class="cov0" title="0">{
                                                        lastTimestamp = logTime.Unix()
                                                }</span>
                                        }
                                }
                        }
                }
        }
}

func fetchLogsWithRetry(apiClient *internal.APIClient, auth *internal.Auth, botID string, params *internal.LogsParams) ([]internal.LogEntry, error) <span class="cov0" title="0">{
        logs, err := apiClient.GetBotLogs(auth, botID, params)
        if err != nil &amp;&amp; internal.IsAuthError(err) </span><span class="cov0" title="0">{
                // Try to get new auth token
                newAuth, authErr := internal.PromptForNewAPIKey()
                if authErr != nil </span><span class="cov0" title="0">{
                        return nil, authErr
                }</span>
                // Retry with new auth
                <span class="cov0" title="0">logs, err = apiClient.GetBotLogs(newAuth, botID, params)</span>
        }
        <span class="cov0" title="0">return logs, err</span>
}

func displayLogEntries(logs []internal.LogEntry) <span class="cov0" title="0">{
        cyan := color.New(color.FgCyan)
        white := color.New(color.FgWhite)

        for _, log := range logs </span><span class="cov0" title="0">{
                // Parse and format date
                logTime, err := time.Parse(time.RFC3339, log.Date)
                var timeStr string
                if err != nil </span><span class="cov0" title="0">{
                        timeStr = log.Date // Fallback to original date string
                }</span> else<span class="cov0" title="0"> {
                        timeStr = logTime.Format("2006-01-02 15:04:05")
                }</span>

                // Display log entry
                <span class="cov0" title="0">fmt.Printf("[%s] %s\n", cyan.Sprint(timeStr), white.Sprint(log.Content))</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package cmd

import (
        "context"
        "fmt"
        "os"
        "time"

        "github.com/spf13/cobra"
        "the0/internal"
)

// VERSION will be set by the main package
var VERSION = "1.0.0" // Default fallback

// SetVersion sets the version for the update commands
func SetVersion(version string) <span class="cov0" title="0">{
        VERSION = version
}</span>

func NewCheckUpdateCmd() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "check-update",
                Short: "Check for available updates",
                Long:  "Check if a newer version of the CLI is available without installing it.",
                RunE:  checkUpdateRun,
        }

        cmd.Flags().Duration("timeout", 10*time.Second, "Request timeout")

        return cmd
}</span>

func checkUpdateRun(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Get flags
        timeout, _ := cmd.Flags().GetDuration("timeout")

        // Get channel from environment variable
        updateChannel := internal.GetUpdateChannel()

        // Create updater
        updater := internal.NewUpdater(internal.UpdateConfig{
                Channel:        updateChannel,
                CurrentVersion: VERSION,
                CheckTimeout:   timeout,
        })

        fmt.Printf("üîç Checking for updates...\n")

        // Check for updates
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        updateAvailable, latestVersion, err := updater.CheckForUpdates(ctx)
        if err != nil </span><span class="cov0" title="0">{
                if ctx.Err() == context.DeadlineExceeded </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "‚è∞ Update check timed out after %v\n", timeout)
                        fmt.Fprintf(os.Stderr, "   Try increasing the timeout with --timeout flag\n")
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to check for updates: %w", err)</span>
        }

        <span class="cov0" title="0">if !updateAvailable </span><span class="cov0" title="0">{
                fmt.Printf("‚úÖ You're running the latest version: %s\n", internal.NormalizeVersion(VERSION))
                return nil
        }</span>

        // Show update information
        <span class="cov0" title="0">fmt.Printf("‚ö†Ô∏è  Update available!\n")
        fmt.Printf("   Current: %s\n", internal.NormalizeVersion(VERSION))
        fmt.Printf("   Latest:  %s\n", internal.NormalizeVersion(latestVersion))
        fmt.Printf("\nüí° Run 'the0 self-update' to update now.\n")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package cmd

import (
        "encoding/json"
        "fmt"
        "os"
        "time"

        "github.com/fatih/color"
        "github.com/olekukonko/tablewriter"
        "github.com/spf13/cobra"
        "the0/internal"
)

func NewCustomBotCmd() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "custom-bot",
                Short: "Manage your custom trading bots",
                Long:  "Deploy, update, and manage your custom trading bots on the0 platform",
        }

        cmd.AddCommand(NewDeployCmd())
        cmd.AddCommand(NewCustomBotListCmd())
        cmd.AddCommand(NewCustomBotSchemaCmd())
        cmd.AddCommand(NewCustomBotVersionsCmd())
        return cmd
}</span>

func NewDeployCmd() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "deploy",
                Short: "Deploy your bot to the0 platform",
                Long:  "Deploy your trading bot to the0 platform",
                Run:   deployBot,
        }
}</span>

func deployBot(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        fmt.Println("Deploying custom bot...")
        fmt.Println("Compiling trading neural pathways")

        // Step 1: Load bot config
        config, err := internal.LoadBotConfig()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "%v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Printf("‚úì Config loaded: %s v%s\n", config.Name, config.Version)

        // Step 2: Validate config
        if err := internal.ValidateBotConfig(config); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Config validation failed: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Println("‚úì Config validated")

        // Step 2.5: Check for dependencies and perform compilation if needed
        if err := internal.PerformVendoringIfNeeded("."); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Dependency compilation failed: %v\n", err)
                internal.CleanupVendoring(".")
                os.Exit(1)
        }</span>

        // Step 3: Get auth token (with retry on failure)
        <span class="cov0" title="0">auth, err := internal.GetAuthTokenWithRetry()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Authentication failed: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Println("‚úì Access granted")

        // Step 4: Check if bot exists and validate ownership
        apiClient := internal.NewAPIClient(internal.GetAPIBaseURL())
        isUpdate, err := apiClient.CheckBotExists(config, auth)
        if err != nil </span><span class="cov0" title="0">{
                // If auth error, try to get new token and retry
                if internal.IsAuthError(err) </span><span class="cov0" title="0">{
                        fmt.Println("Access denied. Reconnecting...")
                        auth, err = internal.PromptForNewAPIKey()
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Authentication failed: %v\n", err)
                                internal.CleanupVendoring(".")
                                os.Exit(1)
                        }</span>

                        // Retry with new key
                        <span class="cov0" title="0">isUpdate, err = apiClient.CheckBotExists(config, auth)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Bot validation failed: %v\n", err)
                                internal.CleanupVendoring(".")
                                os.Exit(1)
                        }</span>
                } else<span class="cov0" title="0"> {
                        fmt.Fprintf(os.Stderr, "Bot validation failed: %v\n", err)
                        internal.CleanupVendoring(".")
                        os.Exit(1)
                }</span>
        }

        <span class="cov0" title="0">if isUpdate </span><span class="cov0" title="0">{
                fmt.Println("Updating existing bot")
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("Deploying new bot")
        }</span>

        // Step 5: Create ZIP file
        <span class="cov0" title="0">zipPath, err := internal.CreateBotZip()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Failed to create ZIP: %v\n", err)
                internal.CleanupVendoring(".")
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer os.Remove(zipPath)

        fmt.Println("‚úì Bot packaged")

        // Step 6: Deploy to API with multipart upload
        if err := apiClient.DeployBot(config, auth, zipPath, isUpdate); err != nil </span><span class="cov0" title="0">{
                // If auth error, try to get new token and retry
                if internal.IsAuthError(err) </span><span class="cov0" title="0">{
                        fmt.Println("Access denied. Reconnecting...")
                        auth, err = internal.PromptForNewAPIKey()
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Authentication failed: %v\n", err)
                                internal.CleanupVendoring(".")
                                os.Exit(1)
                        }</span>

                        // Retry deployment with new key
                        <span class="cov0" title="0">if err := apiClient.DeployBot(config, auth, zipPath, isUpdate); err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Deployment failed: %v\n", err)
                                internal.CleanupVendoring(".")
                                os.Exit(1)
                        }</span>
                } else<span class="cov0" title="0"> {
                        fmt.Fprintf(os.Stderr, "Deployment failed: %v\n", err)
                        internal.CleanupVendoring(".")
                        os.Exit(1)
                }</span>
        }

        <span class="cov0" title="0">fmt.Println("Bot uploaded to the plaform ‚ö°")
        fmt.Printf("'%s' v%s deployed successfully\n", config.Name, config.Version)
        fmt.Println("Awaiting review by the 0vers33r üëÄ")</span>
}

func NewCustomBotListCmd() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "list",
                Short: "List all your deployed custom bots",
                Long:  "üìã List all the custom bots you have deployed with their details",
                Run:   listCustomBots,
        }
}</span>

func NewCustomBotSchemaCmd() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "schema &lt;bot|backtest&gt; &lt;version&gt; &lt;custom-bot-name&gt;",
                Short: "Get the schema of a custom bot",
                Long:  "üìÑ Get the JSON schema for either the bot or backtest entrypoint of a custom bot",
                Args:  cobra.RangeArgs(2, 3), // 2 or 3 arguments
                Run:   getCustomBotSchema,
        }
}</span>

func listCustomBots(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        green := color.New(color.FgGreen)
        red := color.New(color.FgRed)
        blue := color.New(color.FgBlue)

        blue.Println("Scanning deployed bots...")

        // Get auth token
        auth, err := internal.GetAuthTokenWithRetry()
        if err != nil </span><span class="cov0" title="0">{
                red.Fprintf(os.Stderr, "Authentication failed: %v\n", err)
                os.Exit(1)
        }</span>

        // List custom bots
        <span class="cov0" title="0">apiClient := internal.NewAPIClient(internal.GetAPIBaseURL())
        customBots, err := apiClient.ListCustomBots(auth)
        if err != nil </span><span class="cov0" title="0">{
                // Retry with new auth if needed
                if internal.IsAuthError(err) </span><span class="cov0" title="0">{
                        blue.Println("üîë API key appears to be invalid. Let's get a new one...")
                        auth, err = internal.PromptForNewAPIKey()
                        if err != nil </span><span class="cov0" title="0">{
                                red.Fprintf(os.Stderr, "Authentication failed: %v\n", err)
                                os.Exit(1)
                        }</span>

                        // Retry listing
                        <span class="cov0" title="0">customBots, err = apiClient.ListCustomBots(auth)
                        if err != nil </span><span class="cov0" title="0">{
                                red.Fprintf(os.Stderr, "Failed to list custom bots: %v\n", err)
                                os.Exit(1)
                        }</span>
                } else<span class="cov0" title="0"> {
                        red.Fprintf(os.Stderr, "Failed to list custom bots: %v\n", err)
                        os.Exit(1)
                }</span>
        }

        <span class="cov0" title="0">if len(customBots) == 0 </span><span class="cov0" title="0">{
                blue.Println("No custom bots detected. Deploy your first trading bot ü§ñ")
                return
        }</span>

        // Create table
        <span class="cov0" title="0">table := tablewriter.NewWriter(os.Stdout)
        table.Header("Custom Bot Name", "Latest Version", "Created At", "Type")

        for _, customBot := range customBots </span><span class="cov0" title="0">{
                // Convert ISO timestamp to readable date
                createdTime, err := time.Parse(time.RFC3339, customBot.CreatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        createdTime = time.Now() // fallback
                }</span>
                <span class="cov0" title="0">createdStr := createdTime.Format("2006-01-02 15:04")

                // Get the latest version's config to determine type
                var botType string
                if len(customBot.Versions) &gt; 0 </span><span class="cov0" title="0">{
                        // Find the latest version
                        for _, version := range customBot.Versions </span><span class="cov0" title="0">{
                                if version.Version == customBot.LatestVersion </span><span class="cov0" title="0">{
                                        botType = fmt.Sprintf("%s/%s", version.Config.Type, version.Config.Name)
                                        break</span>
                                }
                        }
                }

                <span class="cov0" title="0">if botType == "" </span><span class="cov0" title="0">{
                        botType = "unknown/unknown"
                }</span>

                <span class="cov0" title="0">table.Append(customBot.Name, customBot.LatestVersion, createdStr, botType)</span>
        }

        <span class="cov0" title="0">green.Printf("Found %d custom bot(s) ‚ö°\n\n", len(customBots))
        if err := table.Render(); err != nil </span><span class="cov0" title="0">{
                red.Fprintf(os.Stderr, "Failed to render table: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">green.Println("\nCustom bot portfolio ready for deployment ‚ö°")</span>
}

func getCustomBotSchema(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        green := color.New(color.FgGreen)
        red := color.New(color.FgRed)
        blue := color.New(color.FgBlue)

        entryPointType := args[0] // "bot" or "backtest"
        version := args[1]
        var customBotName string

        if len(args) == 3 </span><span class="cov0" title="0">{
                customBotName = args[2]
        }</span> else<span class="cov0" title="0"> {
                // If version is actually the bot name and no version specified, use latest
                customBotName = version
                version = "" // Will use latest version
        }</span>

        // Validate entry point type
        <span class="cov0" title="0">if entryPointType != "bot" &amp;&amp; entryPointType != "backtest" </span><span class="cov0" title="0">{
                red.Fprintf(os.Stderr, "Entry point type must be 'bot' or 'backtest', got: %s\n", entryPointType)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">blue.Printf("üìÑ Fetching %s schema for custom bot '%s'...\n", entryPointType, customBotName)

        // Get auth token
        auth, err := internal.GetAuthTokenWithRetry()
        if err != nil </span><span class="cov0" title="0">{
                red.Fprintf(os.Stderr, "Authentication failed: %v\n", err)
                os.Exit(1)
        }</span>

        // Get custom bot details
        <span class="cov0" title="0">apiClient := internal.NewAPIClient(internal.GetAPIBaseURL())
        customBot, err := apiClient.GetCustomBot(auth, customBotName)
        if err != nil </span><span class="cov0" title="0">{
                // Retry with new auth if needed
                if internal.IsAuthError(err) </span><span class="cov0" title="0">{
                        blue.Println("üîë API key appears to be invalid. Let's get a new one...")
                        auth, err = internal.PromptForNewAPIKey()
                        if err != nil </span><span class="cov0" title="0">{
                                red.Fprintf(os.Stderr, "Authentication failed: %v\n", err)
                                os.Exit(1)
                        }</span>

                        // Retry fetching
                        <span class="cov0" title="0">customBot, err = apiClient.GetCustomBot(auth, customBotName)
                        if err != nil </span><span class="cov0" title="0">{
                                red.Fprintf(os.Stderr, "Failed to get custom bot: %v\n", err)
                                os.Exit(1)
                        }</span>
                } else<span class="cov0" title="0"> {
                        red.Fprintf(os.Stderr, "Failed to get custom bot: %v\n", err)
                        os.Exit(1)
                }</span>
        }

        // Find the requested version or use latest
        <span class="cov0" title="0">var targetVersion *internal.CustomBotVersion
        if version == "" </span><span class="cov0" title="0">{
                version = customBot.LatestVersion
        }</span>

        <span class="cov0" title="0">for _, v := range customBot.Versions </span><span class="cov0" title="0">{
                if v.Version == version </span><span class="cov0" title="0">{
                        targetVersion = &amp;v
                        break</span>
                }
        }

        <span class="cov0" title="0">if targetVersion == nil </span><span class="cov0" title="0">{
                red.Fprintf(os.Stderr, "Version '%s' not found for custom bot '%s'\n", version, customBotName)
                os.Exit(1)
        }</span>

        // Get the schema for the requested entry point
        <span class="cov0" title="0">var schema map[string]any
        if entryPointType == "bot" </span><span class="cov0" title="0">{
                schema = targetVersion.Config.Schema.Bot
        }</span> else<span class="cov0" title="0"> {
                schema = targetVersion.Config.Schema.Backtest
        }</span>

        <span class="cov0" title="0">if schema == nil || len(schema) == 0 </span><span class="cov0" title="0">{
                blue.Printf("üìÑ No %s schema found for custom bot '%s' version '%s'\n", entryPointType, customBotName, version)
                return
        }</span>

        // Pretty print the schema
        <span class="cov0" title="0">schemaJSON, err := json.MarshalIndent(schema, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                red.Fprintf(os.Stderr, "Failed to format schema: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">green.Printf("üìÑ Schema for custom bot '%s' version '%s' (%s entry point):\n\n", customBotName, version, entryPointType)
        fmt.Println(string(schemaJSON))</span>
}

func NewCustomBotVersionsCmd() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "versions &lt;type|name&gt;",
                Short: "List all versions of a custom bot",
                Long:  "üìã List all versions for a specific custom bot type",
                Args:  cobra.ExactArgs(1),
                Run:   getCustomBotVersions,
        }
}</span>

func getCustomBotVersions(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        green := color.New(color.FgGreen)
        red := color.New(color.FgRed)
        blue := color.New(color.FgBlue)

        typeName := args[0]

        blue.Printf("üìã Fetching versions for custom bot '%s'...\n", typeName)

        auth, err := internal.GetAuthTokenWithRetry()
        if err != nil </span><span class="cov0" title="0">{
                red.Fprintf(os.Stderr, "Authentication failed: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">apiClient := internal.NewAPIClient(internal.GetAPIBaseURL())
        customBots, err := apiClient.ListCustomBots(auth)
        if err != nil </span><span class="cov0" title="0">{
                if internal.IsAuthError(err) </span><span class="cov0" title="0">{
                        blue.Println("üîë API key appears to be invalid. Let's get a new one...")
                        auth, err = internal.PromptForNewAPIKey()
                        if err != nil </span><span class="cov0" title="0">{
                                red.Fprintf(os.Stderr, "Authentication failed: %v\n", err)
                                os.Exit(1)
                        }</span>

                        <span class="cov0" title="0">customBots, err = apiClient.ListCustomBots(auth)
                        if err != nil </span><span class="cov0" title="0">{
                                red.Fprintf(os.Stderr, "Failed to list custom bots: %v\n", err)
                                os.Exit(1)
                        }</span>
                } else<span class="cov0" title="0"> {
                        red.Fprintf(os.Stderr, "Failed to list custom bots: %v\n", err)
                        os.Exit(1)
                }</span>
        }

        <span class="cov0" title="0">var targetCustomBot *internal.CustomBotData
        for _, customBot := range customBots </span><span class="cov0" title="0">{
                if len(customBot.Versions) &gt; 0 </span><span class="cov0" title="0">{
                        for _, version := range customBot.Versions </span><span class="cov0" title="0">{
                                if version.Version == customBot.LatestVersion </span><span class="cov0" title="0">{
                                        botType := fmt.Sprintf("%s/%s", version.Config.Type, version.Config.Name)
                                        if botType == typeName || customBot.Name == typeName </span><span class="cov0" title="0">{
                                                targetCustomBot = &amp;customBot
                                                break</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">if targetCustomBot != nil </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">if targetCustomBot == nil </span><span class="cov0" title="0">{
                red.Fprintf(os.Stderr, "Custom bot not found: %s\n", typeName)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if len(targetCustomBot.Versions) == 0 </span><span class="cov0" title="0">{
                blue.Printf("ü§∑ No versions found for custom bot '%s'\n", typeName)
                return
        }</span>

        <span class="cov0" title="0">table := tablewriter.NewWriter(os.Stdout)
        table.Header("Version", "Created At", "Type")

        for _, version := range targetCustomBot.Versions </span><span class="cov0" title="0">{
                createdTime, err := time.Parse(time.RFC3339, version.CreatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        createdTime = time.Now() // fallback
                }</span>
                <span class="cov0" title="0">createdStr := createdTime.Format("2006-01-02 15:04")

                botType := fmt.Sprintf("%s/%s", version.Config.Type, version.Config.Name)

                table.Append(version.Version, createdStr, botType)</span>
        }

        <span class="cov0" title="0">green.Printf("üìã Found %d version(s) for custom bot '%s':\n\n", len(targetCustomBot.Versions), typeName)
        if err := table.Render(); err != nil </span><span class="cov0" title="0">{
                red.Fprintf(os.Stderr, "Failed to render table: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">green.Println("\nüéâ Version history looking solid! üöÄ")</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package cmd

import (
        "context"
        "fmt"
        "os"
        "time"

        "github.com/spf13/cobra"
        "the0/internal"
)

// Use the VERSION variable from check_update.go (same package)

func NewSelfUpdateCmd() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "self-update",
                Short: "Update the CLI to the latest version",
                Long:  "Download and install the latest version of the CLI binary.",
                RunE:  selfUpdateRun,
        }

        cmd.Flags().Duration("timeout", 5*time.Minute, "Download timeout")
        cmd.Flags().Bool("check-only", false, "Only check for updates, don't install")
        cmd.Flags().Bool("force", false, "Force update even if already on latest version")
        cmd.Flags().Bool("yes", false, "Skip confirmation prompt")

        return cmd
}</span>

func selfUpdateRun(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Get flags
        timeout, _ := cmd.Flags().GetDuration("timeout")
        checkOnly, _ := cmd.Flags().GetBool("check-only")
        force, _ := cmd.Flags().GetBool("force")
        yes, _ := cmd.Flags().GetBool("yes")

        // Get channel from environment variable
        updateChannel := internal.GetUpdateChannel()

        // Create updater
        updater := internal.NewUpdater(internal.UpdateConfig{
                Channel:         updateChannel,
                CurrentVersion:  VERSION,
                CheckTimeout:    10 * time.Second,
                DownloadTimeout: timeout,
        })

        fmt.Printf("üîç Checking for updates...\n")

        // Check for updates
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        updateAvailable, latestVersion, err := updater.CheckForUpdates(ctx)
        if err != nil </span><span class="cov0" title="0">{
                if ctx.Err() == context.DeadlineExceeded </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "‚è∞ Update check timed out\n")
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to check for updates: %w", err)</span>
        }

        <span class="cov0" title="0">if !updateAvailable &amp;&amp; !force </span><span class="cov0" title="0">{
                fmt.Printf("‚úÖ You're already running the latest version: %s\n", internal.NormalizeVersion(VERSION))
                return nil
        }</span>

        // Show update information
        <span class="cov0" title="0">if updateAvailable </span><span class="cov0" title="0">{
                fmt.Printf("‚ö†Ô∏è  Update available!\n")
                fmt.Printf("   Current: %s\n", internal.NormalizeVersion(VERSION))
                fmt.Printf("   Latest:  %s\n", internal.NormalizeVersion(latestVersion))
        }</span> else<span class="cov0" title="0"> if force </span><span class="cov0" title="0">{
                fmt.Printf("üîÑ Forcing update to latest version: %s\n", internal.NormalizeVersion(latestVersion))
        }</span>

        // If check-only, exit here
        <span class="cov0" title="0">if checkOnly </span><span class="cov0" title="0">{
                if updateAvailable </span><span class="cov0" title="0">{
                        fmt.Printf("\nüí° Run 'the0 self-update' to install the update.\n")
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Confirmation prompt (unless --yes is used)
        <span class="cov0" title="0">if !yes </span><span class="cov0" title="0">{
                fmt.Printf("\n‚ùì Do you want to update now? [y/N]: ")
                var response string
                fmt.Scanln(&amp;response)

                if response != "y" &amp;&amp; response != "Y" &amp;&amp; response != "yes" &amp;&amp; response != "Yes" </span><span class="cov0" title="0">{
                        fmt.Println("Update cancelled.")
                        return nil
                }</span>
        }

        // Perform the update
        <span class="cov0" title="0">fmt.Printf("\nüöÄ Starting update process...\n")

        // Progress callback
        var lastPercent int
        progressCallback := func(written, total int64) </span><span class="cov0" title="0">{
                if total &gt; 0 </span><span class="cov0" title="0">{
                        percent := int((written * 100) / total)
                        if percent != lastPercent &amp;&amp; percent%5 == 0 </span><span class="cov0" title="0">{
                                fmt.Printf("üì¶ Downloading: %d%% (%d/%d bytes)\n", percent, written, total)
                                lastPercent = percent
                        }</span>
                }
        }

        // Use extended timeout for the update process
        <span class="cov0" title="0">updateCtx, updateCancel := context.WithTimeout(context.Background(), timeout)
        defer updateCancel()

        err = updater.SelfUpdate(updateCtx, progressCallback)
        if err != nil </span><span class="cov0" title="0">{
                if updateCtx.Err() == context.DeadlineExceeded </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "‚è∞ Update timed out after %v\n", timeout)
                        fmt.Fprintf(os.Stderr, "   Try increasing the timeout with --timeout flag\n")
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("update failed: %w", err)</span>
        }

        <span class="cov0" title="0">fmt.Printf("\nüéâ Update completed successfully!\n")
        fmt.Printf("   New version: %s\n", internal.NormalizeVersion(latestVersion))
        fmt.Printf("\nüí° The update will take effect the next time you run the CLI.\n")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package internal

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "mime/multipart"
        "net/http"
        "os"
        "path/filepath"
        "time"

        "github.com/Masterminds/semver/v3"
)

const DEFAULT_API_URL = "http://localhost:3000"

// APIClient handles all API interactions
type APIClient struct {
        BaseURL    string
        HTTPClient *http.Client
}

// Schema represents the JSON schema structure
type Schema struct {
        Backtest map[string]any `json:"backtest"`
        Bot      map[string]any `json:"bot"`
}

// APIBotConfig represents the config structure returned by the API
type APIBotConfig struct {
        Name        string            `json:"name"`
        Description string            `json:"description"`
        Version     string            `json:"version"`
        Author      string            `json:"author"`
        Type        string            `json:"type"`
        Entrypoints map[string]string `json:"entrypoints"`
        Schema      Schema            `json:"schema"`
        Readme      string            `json:"readme"`
        Metadata    map[string]any    `json:"metadata"`
}

// CustomBotVersion represents a single version of a custom bot
type CustomBotVersion struct {
        Version   string       `json:"version"`
        Config    APIBotConfig `json:"config"`
        FilePath   string       `json:"FilePath"`
        CreatedAt string       `json:"createdAt"`
        UpdatedAt string       `json:"updatedAt"`
}

// CustomBotData represents the data structure returned by the API
type CustomBotData struct {
        ID            string             `json:"id"`
        Name          string             `json:"name"`
        UserId        string             `json:"userId"`
        LatestVersion string             `json:"latestVersion"`
        Versions      []CustomBotVersion `json:"versions"`
        CreatedAt     string `json:"createdAt"`
        UpdatedAt     string `json:"updatedAt"`
}

// CustomBotAPIResponse represents the full API response structure
type CustomBotAPIResponse struct {
        Success bool          `json:"success"`
        Data    CustomBotData `json:"data"`
        Message string        `json:"message"`
}

// BotInstance represents a deployed bot instance
type BotInstance struct {
        ID        string         `json:"id"`
        Name      string         `json:"name"`
        Config    map[string]any `json:"config"`
        Topic     string         `json:"topic"`
        CreatedAt   string `json:"createdAt"`
        UpdatedAt   string `json:"updatedAt"`
        UserID      string `json:"userId"`
        CustomBotId string `json:"customBotId"`
}

// BacktestInstance represents a deployed backtest instance
type BacktestInstance struct {
        ID          string         `json:"id"`
        Name        string         `json:"name"`
        Config      map[string]any `json:"config"`
        Status      string         `json:"status"`
        Progress    float64        `json:"progress,omitempty"`
        Results     map[string]any `json:"results,omitempty"`
        CreatedAt   string         `json:"createdAt"`
        UpdatedAt   string `json:"updatedAt"`
        UserID      string         `json:"userId"`
        CustomBotId string         `json:"customBotId"`
}

// BotListResponse represents the response for listing bot instances
type BotListResponse []BotInstance

// BotDeployRequest represents the request for deploying a bot instance
type BotDeployRequest struct {
        Name   string         `json:"name"`
        Config map[string]any `json:"config"`
}

// BotUpdateRequest represents the request for updating a bot instance
type BotUpdateRequest struct {
        Name   string         `json:"name"`
        Config map[string]any `json:"config"`
}

// BacktestDeployRequest represents the request for deploying a backtest
type BacktestDeployRequest struct {
        Name   string         `json:"name"`
        Config map[string]any `json:"config"`
}

// APIResponse represents a generic API response
type APIResponse struct {
        Success bool   `json:"success"`
        Data    any    `json:"data,omitempty"`
        Message string `json:"message"`
}


// CustomBotDeployRequest represents the new deploy request with file path
type CustomBotDeployRequest struct {
        Config   string `json:"config"`
        FilePath string `json:"filePath"`
}

// NewAPIClient creates a new API client
func NewAPIClient(baseURL string) *APIClient <span class="cov0" title="0">{
        return &amp;APIClient{
                BaseURL: baseURL,
                HTTPClient: &amp;http.Client{
                        Timeout: 60 * time.Second,
                },
        }
}</span>

// GetAPIBaseURL returns the API base URL from environment or default
func GetAPIBaseURL() string <span class="cov0" title="0">{
        if url := os.Getenv("THE0_API_URL"); url != "" </span><span class="cov0" title="0">{
                return url
        }</span>
        <span class="cov0" title="0">return DEFAULT_API_URL</span>
}

// APIKeyValidationResponse represents the response from the API key validation endpoint
type APIKeyValidationResponse struct {
        Success bool `json:"success"`
        Data    struct {
                Valid      bool   `json:"valid"`
                UserID     string `json:"userId"`
                KeyID      string `json:"keyId"`
                KeyName    string `json:"keyName"`
                LastUsedAt string `json:"lastUsedAt"`
        } `json:"data"`
        Message string `json:"message"`
}

// LogEntry represents a single log entry
type LogEntry struct {
        Date    string `json:"date"`
        Content string `json:"content"`
}

// LogsResponse represents the API response for bot logs
type LogsResponse struct {
        Success bool       `json:"success"`
        Data    []LogEntry `json:"data"`
        Message string     `json:"message"`
}

// LogsParams represents parameters for the logs API call
type LogsParams struct {
        Date      string `json:"date,omitempty"`
        DateRange string `json:"dateRange,omitempty"`
        Limit     int    `json:"limit,omitempty"`
}

// TestAPIKey tests if an API key is valid
func (c *APIClient) TestAPIKey(auth *Auth) error <span class="cov0" title="0">{
        req, err := http.NewRequest("GET", c.BaseURL+"/auth/validate-api-key", nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "ApiKey "+auth.APIKey)

        resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("network error: %v", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read response body: %v", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode == 401 || resp.StatusCode == 403 </span><span class="cov0" title="0">{
                return fmt.Errorf("API key is invalid or revoked")
        }</span>

        <span class="cov0" title="0">if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                return fmt.Errorf("API error: %d - %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var apiResponse APIKeyValidationResponse
        if err := json.Unmarshal(body, &amp;apiResponse); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse API response: %v", err)
        }</span>

        <span class="cov0" title="0">if !apiResponse.Success </span><span class="cov0" title="0">{
                return fmt.Errorf("API key validation failed: %s", apiResponse.Message)
        }</span>

        <span class="cov0" title="0">if !apiResponse.Data.Valid </span><span class="cov0" title="0">{
                return fmt.Errorf("API key is invalid")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CheckBotExists checks if a bot exists and validates ownership
func (c *APIClient) CheckBotExists(config *BotConfig, auth *Auth) (bool, error) <span class="cov0" title="0">{
        req, err := http.NewRequest("GET", fmt.Sprintf("%s/custom-bots/%s", c.BaseURL, config.Name), nil)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "ApiKey "+auth.APIKey)

        resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                // Bot doesn't exist, this is a new deployment
                return false, nil
        }</span>

        <span class="cov0" title="0">if resp.StatusCode == 401 || resp.StatusCode == 403 </span><span class="cov0" title="0">{
                return false, fmt.Errorf("authentication failed: API key is invalid or revoked")
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check bot existence: HTTP %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to read response body: %v", err)
        }</span>

        <span class="cov0" title="0">var apiResponse CustomBotAPIResponse
        if err := json.Unmarshal(body, &amp;apiResponse); err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to parse API response: %v", err)
        }</span>

        <span class="cov0" title="0">if !apiResponse.Success </span><span class="cov0" title="0">{
                return false, fmt.Errorf("API returned error: %s", apiResponse.Message)
        }</span>

        <span class="cov0" title="0">botData := apiResponse.Data
        // Check version for updates
        currentVersion, err := semver.NewVersion(botData.LatestVersion)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("invalid current version: %v", err)
        }</span>

        <span class="cov0" title="0">newVersion, err := semver.NewVersion(config.Version)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("invalid new version: %v", err)
        }</span>

        <span class="cov0" title="0">if !newVersion.GreaterThan(currentVersion) </span><span class="cov0" title="0">{
                return false, fmt.Errorf("new version (%s) must be greater than current version (%s). Time to level up! üìà", config.Version, botData.LatestVersion)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Bot %s is ready for update! Current version: %s, New version: %s\n", config.Name, botData.LatestVersion, config.Version)

        return true, nil</span>
}

// DeployBot deploys a bot using direct upload: upload file and deploy in one step
func (c *APIClient) DeployBot(config *BotConfig, auth *Auth, zipPath string, isUpdate bool) error <span class="cov0" title="0">{
        fmt.Println("üöÄ Starting deployment process...")

        // Step 1: Upload ZIP file directly to API
        fmt.Printf("üì¶ Uploading %s to API...\n", filepath.Base(zipPath))
        filePath, err := c.UploadFileDirect(config.Name, config.Version, zipPath, auth)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to upload file: %v", err)
        }</span>
        <span class="cov0" title="0">fmt.Println("‚úÖ File uploaded successfully!")

        // Step 2: Deploy with config and file path
        fmt.Println("üîß Configuring deployment...")

        // Read README content
        readmeContent, err := os.ReadFile(config.Readme)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read README: %v", err)
        }</span>

        // Read and parse JSON schema files
        <span class="cov0" title="0">var backtestSchema map[string]any
        if config.Schema.Backtest != "" </span><span class="cov0" title="0">{
                backtestSchemaData, err := os.ReadFile(config.Schema.Backtest)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read backtest schema: %v", err)
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal(backtestSchemaData, &amp;backtestSchema); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid JSON in backtest schema: %v", err)
                }</span>
        }

        <span class="cov0" title="0">botSchemaData, err := os.ReadFile(config.Schema.Bot)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read bot schema: %v", err)
        }</span>

        <span class="cov0" title="0">var botSchema map[string]any
        if err := json.Unmarshal(botSchemaData, &amp;botSchema); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid JSON in bot schema: %v", err)
        }</span>

        // Prepare entrypoints (only include backtest if specified)
        <span class="cov0" title="0">entrypoints := map[string]any{
                "bot": config.Entrypoints.Bot,
        }
        if config.Entrypoints.Backtest != "" </span><span class="cov0" title="0">{
                entrypoints["backtest"] = config.Entrypoints.Backtest
        }</span>

        // Prepare schema (only include backtest if specified)
        <span class="cov0" title="0">schema := map[string]any{
                "bot": botSchema,
        }
        if backtestSchema != nil </span><span class="cov0" title="0">{
                schema["backtest"] = backtestSchema
        }</span>

        // Prepare config payload
        <span class="cov0" title="0">configPayload := map[string]any{
                "name":        config.Name,
                "description": config.Description,
                "runtime":     config.Runtime,
                "version":     config.Version,
                "author":      config.Author,
                "type":        config.Type,
                "entrypoints": entrypoints,
                "schema":      schema,
                "readme":      string(readmeContent),
                "metadata":    config.Metadata,
        }

        configJSON, err := json.Marshal(configPayload)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config: %v", err)
        }</span>

        // Create deploy request
        <span class="cov0" title="0">deployRequest := CustomBotDeployRequest{
                Config:   string(configJSON),
                FilePath: filePath,
        }

        deployRequestJSON, err := json.Marshal(deployRequest)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal deploy request: %v", err)
        }</span>

        // Create HTTP request
        <span class="cov0" title="0">var endpoint string
        var method string

        if isUpdate </span><span class="cov0" title="0">{
                endpoint = fmt.Sprintf("%s/custom-bots/%s", c.BaseURL, config.Name)
                method = "PUT"
        }</span> else<span class="cov0" title="0"> {
                endpoint = fmt.Sprintf("%s/custom-bots/%s", c.BaseURL, config.Name)
                method = "POST"
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest(method, endpoint, bytes.NewBuffer(deployRequestJSON))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %v", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "ApiKey "+auth.APIKey)
        req.Header.Set("Content-Type", "application/json")

        resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("network error: %v", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode == 401 || resp.StatusCode == 403 </span><span class="cov0" title="0">{
                return fmt.Errorf("authentication failed: API key is invalid or revoked")
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != 200 &amp;&amp; resp.StatusCode != 201 </span><span class="cov0" title="0">{
                // Try to read error message from response
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("deployment failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">fmt.Println("üéâ Deployment configured successfully!")
        return nil</span>
}

// BotListAPIResponse represents the response structure for bot list API
type BotListAPIResponse struct {
        Success bool          `json:"success"`
        Data    []BotInstance `json:"data"`
        Message string        `json:"message"`
}

// BacktestAPIResponse represents the full API response structure for backtests
type BacktestAPIResponse struct {
        Success bool              `json:"success"`
        Data    []BacktestInstance `json:"data"`
        Message string            `json:"message"`
}

// SingleBacktestAPIResponse represents API response for single backtest operations
type SingleBacktestAPIResponse struct {
        Success bool         `json:"success"`
        Data    BacktestInstance `json:"data"`
        Message string       `json:"message"`
}

// ListBots retrieves the list of deployed bot instances
func (c *APIClient) ListBots(auth *Auth) ([]BotInstance, error) <span class="cov0" title="0">{
        req, err := http.NewRequest("GET", c.BaseURL+"/bot", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %v", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "ApiKey "+auth.APIKey)

        resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("network error: %v", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode == 401 || resp.StatusCode == 403 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("authentication failed: API key is invalid or revoked")
        }</span>

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response body: %v", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API error: %d - %s", resp.StatusCode, string(body))
        }</span>

        // Try to parse as wrapped response first
        <span class="cov0" title="0">var apiResponse BotListAPIResponse
        if err := json.Unmarshal(body, &amp;apiResponse); err == nil </span><span class="cov0" title="0">{
                if !apiResponse.Success </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("API returned error: %s", apiResponse.Message)
                }</span>
                <span class="cov0" title="0">return apiResponse.Data, nil</span>
        }

        // Fallback: try to parse as direct array (for backward compatibility)
        <span class="cov0" title="0">var bots []BotInstance
        if err := json.Unmarshal(body, &amp;bots); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse API response: %v", err)
        }</span>

        <span class="cov0" title="0">return bots, nil</span>
}

// DeployBotInstance deploys a new bot instance
func (c *APIClient) DeployBotInstance(auth *Auth, request *BotDeployRequest) (*BotInstance, error) <span class="cov0" title="0">{
        reqBody, err := json.Marshal(request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal request: %v", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("POST", c.BaseURL+"/bot", bytes.NewBuffer(reqBody))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %v", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "ApiKey "+auth.APIKey)
        req.Header.Set("Content-Type", "application/json")

        resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("network error: %v", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode == 401 || resp.StatusCode == 403 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("authentication failed: API key is invalid or revoked")
        }</span>

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response body: %v", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != 200 &amp;&amp; resp.StatusCode != 201 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("deployment failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var botInstance BotInstance
        if err := json.Unmarshal(body, &amp;botInstance); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse API response: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;botInstance, nil</span>
}

// UpdateBotInstance updates an existing bot instance
func (c *APIClient) UpdateBotInstance(auth *Auth, botID string, request *BotUpdateRequest) error <span class="cov0" title="0">{
        reqBody, err := json.Marshal(request)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal request: %v", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("PUT", fmt.Sprintf("%s/bot/%s", c.BaseURL, botID), bytes.NewBuffer(reqBody))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %v", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "ApiKey "+auth.APIKey)
        req.Header.Set("Content-Type", "application/json")

        resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("network error: %v", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode == 401 || resp.StatusCode == 403 </span><span class="cov0" title="0">{
                return fmt.Errorf("authentication failed: API key is invalid or revoked")
        }</span>

        <span class="cov0" title="0">if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                return fmt.Errorf("bot not found: %s", botID)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("update failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UserBot represents a user-installed bot instance
type UserBot struct {
        ID            string         `json:"id"`
        CustomBotName string         `json:"customBotName"`
        CustomBot     *CustomBotData `json:"customBot,omitempty"`
        AcquiredAt    string `json:"acquiredAt"`
}

// UserBotListResponse represents the response for listing user bots
type UserBotListResponse struct {
        Success bool      `json:"success"`
        Data    []UserBot `json:"data"`
        Message string    `json:"message"`
}

// CustomBotListResponse represents the response for listing custom bots
type CustomBotListResponse struct {
        Success bool            `json:"success"`
        Data    []CustomBotData `json:"data"`
        Message string          `json:"message"`
}

// DeleteBotInstance deletes a bot instance
func (c *APIClient) DeleteBotInstance(auth *Auth, botID string) error <span class="cov0" title="0">{
        req, err := http.NewRequest("DELETE", fmt.Sprintf("%s/bot/%s", c.BaseURL, botID), nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %v", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "ApiKey "+auth.APIKey)

        resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("network error: %v", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode == 401 || resp.StatusCode == 403 </span><span class="cov0" title="0">{
                return fmt.Errorf("authentication failed: API key is invalid or revoked")
        }</span>

        <span class="cov0" title="0">if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                return fmt.Errorf("bot not found: %s", botID)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != 200 &amp;&amp; resp.StatusCode != 204 </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("deletion failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// FindBotByNameOrID finds a bot by either name or ID
func (c *APIClient) FindBotByNameOrID(auth *Auth, identifier string) (*BotInstance, error) <span class="cov0" title="0">{
        bots, err := c.ListBots(auth)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, bot := range bots </span><span class="cov0" title="0">{
                if bot.ID == identifier || bot.Name == identifier </span><span class="cov0" title="0">{
                        return &amp;bot, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("bot not found: %s", identifier)</span>
}

// ListUserBots retrieves the list of user-installed bots
func (c *APIClient) ListUserBots(auth *Auth) ([]UserBot, error) <span class="cov0" title="0">{
        req, err := http.NewRequest("GET", c.BaseURL+"/user-bots", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %v", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "ApiKey "+auth.APIKey)

        resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("network error: %v", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode == 401 || resp.StatusCode == 403 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("authentication failed: API key is invalid or revoked")
        }</span>

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response body: %v", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API error: %d - %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var apiResponse UserBotListResponse
        if err := json.Unmarshal(body, &amp;apiResponse); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse API response: %v", err)
        }</span>

        <span class="cov0" title="0">if !apiResponse.Success </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API returned error: %s", apiResponse.Message)
        }</span>

        <span class="cov0" title="0">return apiResponse.Data, nil</span>
}

// ListCustomBots retrieves the list of user's custom bots
func (c *APIClient) ListCustomBots(auth *Auth) ([]CustomBotData, error) <span class="cov0" title="0">{
        req, err := http.NewRequest("GET", c.BaseURL+"/custom-bots", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %v", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "ApiKey "+auth.APIKey)

        resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("network error: %v", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode == 401 || resp.StatusCode == 403 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("authentication failed: API key is invalid or revoked")
        }</span>

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response body: %v", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API error: %d - %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var apiResponse CustomBotListResponse
        if err := json.Unmarshal(body, &amp;apiResponse); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse API response: %v", err)
        }</span>

        <span class="cov0" title="0">if !apiResponse.Success </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API returned error: %s", apiResponse.Message)
        }</span>

        <span class="cov0" title="0">return apiResponse.Data, nil</span>
}

// GetCustomBot retrieves a specific custom bot by name
func (c *APIClient) GetCustomBot(auth *Auth, customBotName string) (*CustomBotData, error) <span class="cov0" title="0">{
        req, err := http.NewRequest("GET", fmt.Sprintf("%s/custom-bots/%s", c.BaseURL, customBotName), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %v", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "ApiKey "+auth.APIKey)

        resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("network error: %v", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode == 401 || resp.StatusCode == 403 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("authentication failed: API key is invalid or revoked")
        }</span>

        <span class="cov0" title="0">if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("custom bot not found: %s", customBotName)
        }</span>

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response body: %v", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API error: %d - %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var apiResponse CustomBotAPIResponse
        if err := json.Unmarshal(body, &amp;apiResponse); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse API response: %v", err)
        }</span>

        <span class="cov0" title="0">if !apiResponse.Success </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API returned error: %s", apiResponse.Message)
        }</span>

        <span class="cov0" title="0">return &amp;apiResponse.Data, nil</span>
}

// GetBotLogs retrieves logs for a specific bot
func (c *APIClient) GetBotLogs(auth *Auth, botID string, params *LogsParams) ([]LogEntry, error) <span class="cov0" title="0">{
        // Build URL with query parameters
        url := fmt.Sprintf("%s/logs/%s", c.BaseURL, botID)
        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %v", err)
        }</span>

        // Add query parameters
        <span class="cov0" title="0">if params != nil </span><span class="cov0" title="0">{
                q := req.URL.Query()
                if params.Date != "" </span><span class="cov0" title="0">{
                        q.Add("date", params.Date)
                }</span>
                <span class="cov0" title="0">if params.DateRange != "" </span><span class="cov0" title="0">{
                        q.Add("dateRange", params.DateRange)
                }</span>
                <span class="cov0" title="0">if params.Limit &gt; 0 </span><span class="cov0" title="0">{
                        q.Add("limit", fmt.Sprintf("%d", params.Limit))
                }</span>
                <span class="cov0" title="0">req.URL.RawQuery = q.Encode()</span>
        }

        <span class="cov0" title="0">req.Header.Set("Authorization", "ApiKey "+auth.APIKey)

        resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("network error: %v", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("network error: %v", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode == 401 || resp.StatusCode == 403 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("authentication failed: API key is invalid or revoked")
        }</span>

        <span class="cov0" title="0">if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("bot not found: %s", botID)
        }</span>

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response body: %v", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API error: %d - %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var apiResponse LogsResponse
        if err := json.Unmarshal(body, &amp;apiResponse); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse API response: %v", err)
        }</span>

        <span class="cov0" title="0">if !apiResponse.Success </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API returned error: %s", apiResponse.Message)
        }</span>

        <span class="cov0" title="0">return apiResponse.Data, nil</span>
}

// UploadFileDirect uploads a file directly to the API using multipart form data
func (c *APIClient) UploadFileDirect(botName string, version string, filePath string, auth *Auth) (string, error) <span class="cov0" title="0">{
        // Open the file
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to open file: %v", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Create a buffer to write our multipart form
        var requestBody bytes.Buffer
        writer := multipart.NewWriter(&amp;requestBody)

        // Add version field
        err = writer.WriteField("version", version)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to write version field: %v", err)
        }</span>

        // Create the file field
        <span class="cov0" title="0">part, err := writer.CreateFormFile("file", filepath.Base(filePath))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create form file: %v", err)
        }</span>

        // Copy file content to the form
        <span class="cov0" title="0">_, err = io.Copy(part, file)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to copy file content: %v", err)
        }</span>

        // Close the writer to finalize the multipart message
        <span class="cov0" title="0">err = writer.Close()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to close writer: %v", err)
        }</span>

        // Create POST request with multipart form data
        <span class="cov0" title="0">req, err := http.NewRequest("POST", fmt.Sprintf("%s/custom-bots/%s/upload", c.BaseURL, botName), &amp;requestBody)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create upload request: %v", err)
        }</span>

        // Set required headers
        <span class="cov0" title="0">req.Header.Set("Content-Type", writer.FormDataContentType())
        req.Header.Set("Authorization", "ApiKey "+auth.APIKey)

        // Use a longer timeout for large file uploads
        client := &amp;http.Client{
                Timeout: 30 * time.Minute, // 30 minutes for large files
        }

        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("upload failed: %v", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Read response body
        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read response body: %v", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("upload failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        // Parse the response as a flat structure instead of wrapped
        <span class="cov0" title="0">var uploadResponse struct {
                Success bool   `json:"success"`
                FilePath string `json:"filePath"`
                Message string `json:"message"`
        }

        if err := json.Unmarshal(body, &amp;uploadResponse); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse upload response: %v", err)
        }</span>

        <span class="cov0" title="0">if !uploadResponse.Success </span><span class="cov0" title="0">{
                return "", fmt.Errorf("upload failed: %s", uploadResponse.Message)
        }</span>

        // Extract file path directly from response
        <span class="cov0" title="0">if uploadResponse.FilePath == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("file path not found in response")
        }</span>

        <span class="cov0" title="0">return uploadResponse.FilePath, nil</span>
}

// CreateBacktest deploys a new backtest instance
func (c *APIClient) CreateBacktest(auth *Auth, request *BacktestDeployRequest) (*BacktestInstance, error) <span class="cov0" title="0">{
        requestData, err := json.Marshal(request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal request: %v", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("POST", c.BaseURL+"/backtest", bytes.NewBuffer(requestData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %v", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "ApiKey "+auth.APIKey)
        req.Header.Set("Content-Type", "application/json")

        resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("network error: %v", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode == 401 || resp.StatusCode == 403 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("authentication failed: API key is invalid or revoked")
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != 200 &amp;&amp; resp.StatusCode != 201 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API error: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response body: %v", err)
        }</span>

        <span class="cov0" title="0">var backtest BacktestInstance
        if err := json.Unmarshal(body, &amp;backtest); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse API response: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;backtest, nil</span>
}

// ListBacktests retrieves all backtest instances for the authenticated user
func (c *APIClient) ListBacktests(auth *Auth) ([]BacktestInstance, error) <span class="cov0" title="0">{
        req, err := http.NewRequest("GET", c.BaseURL+"/backtest", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %v", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "ApiKey "+auth.APIKey)

        resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("network error: %v", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode == 401 || resp.StatusCode == 403 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("authentication failed: API key is invalid or revoked")
        }</span>

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response body: %v", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API error: %d - %s", resp.StatusCode, string(body))
        }</span>

        // Try to parse as wrapped response first
        <span class="cov0" title="0">var apiResponse BacktestAPIResponse
        if err := json.Unmarshal(body, &amp;apiResponse); err == nil </span><span class="cov0" title="0">{
                if !apiResponse.Success </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("API returned error: %s", apiResponse.Message)
                }</span>
                <span class="cov0" title="0">return apiResponse.Data, nil</span>
        }

        // Fallback: try to parse as direct array (for backward compatibility)
        <span class="cov0" title="0">var backtests []BacktestInstance
        if err := json.Unmarshal(body, &amp;backtests); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse API response: %v", err)
        }</span>

        <span class="cov0" title="0">return backtests, nil</span>
}

// DeleteBacktest deletes a specific backtest instance
func (c *APIClient) DeleteBacktest(auth *Auth, backtestID string) error <span class="cov0" title="0">{
        req, err := http.NewRequest("DELETE", c.BaseURL+"/backtest/"+backtestID, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %v", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "ApiKey "+auth.APIKey)

        resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("network error: %v", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode == 401 || resp.StatusCode == 403 </span><span class="cov0" title="0">{
                return fmt.Errorf("authentication failed: API key is invalid or revoked")
        }</span>

        <span class="cov0" title="0">if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                return fmt.Errorf("backtest not found: %s", backtestID)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != 200 &amp;&amp; resp.StatusCode != 204 </span><span class="cov0" title="0">{
                return fmt.Errorf("API error: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package internal

import (
        "bufio"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"
)

const AUTH_FILE = ".the0/auth.json"

// Auth represents the authentication structure
type Auth struct {
        APIKey    string    `json:"api_key"`
        CreatedAt time.Time `json:"created_at"`
}

// LoadAuth loads authentication from file
func LoadAuth() (*Auth, error) <span class="cov0" title="0">{
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">authPath := filepath.Join(homeDir, AUTH_FILE)
        data, err := os.ReadFile(authPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var auth Auth
        if err := json.Unmarshal(data, &amp;auth); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;auth, nil</span>
}

// SaveAuth saves authentication to file
func SaveAuth(auth *Auth) error <span class="cov0" title="0">{
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">authDir := filepath.Join(homeDir, ".the0")
        if err := os.MkdirAll(authDir, 0700); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">authPath := filepath.Join(homeDir, AUTH_FILE)
        data, err := json.MarshalIndent(auth, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return os.WriteFile(authPath, data, 0600)</span>
}

// RemoveAuth removes the saved authentication
func RemoveAuth() error <span class="cov0" title="0">{
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">authPath := filepath.Join(homeDir, AUTH_FILE)
        return os.Remove(authPath)</span>
}

// PromptForNewAPIKey prompts the user for a new API key
func PromptForNewAPIKey() (*Auth, error) <span class="cov0" title="0">{
        reader := bufio.NewReader(os.Stdin)

        fmt.Print("Enter your the0 API key: ")
        apiKey, err := reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">apiKey = strings.TrimSpace(apiKey)

        if apiKey == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API key cannot be empty")
        }</span>

        <span class="cov0" title="0">auth := &amp;Auth{
                APIKey:    apiKey,
                CreatedAt: time.Now(),
        }

        // Save the auth
        if err := SaveAuth(auth); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save API key: %v", err)
        }</span>

        <span class="cov0" title="0">return auth, nil</span>
}

// GetAuthTokenWithRetry gets auth token with retry logic
func GetAuthTokenWithRetry() (*Auth, error) <span class="cov0" title="0">{
        auth, err := LoadAuth()
        if err != nil </span><span class="cov0" title="0">{
                // No saved auth, prompt for API key
                return PromptForNewAPIKey()
        }</span>

        // Test the existing key
        <span class="cov0" title="0">apiClient := NewAPIClient(GetAPIBaseURL())
        if err := apiClient.TestAPIKey(auth); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Saved credentials invalid: %v\n", err)
                return PromptForNewAPIKey()
        }</span>

        <span class="cov0" title="0">return auth, nil</span>
}

// IsAuthError checks if an error is authentication related
func IsAuthError(err error) bool <span class="cov0" title="0">{
        return strings.Contains(err.Error(), "401") ||
                strings.Contains(err.Error(), "403") ||
                strings.Contains(err.Error(), "invalid") ||
                strings.Contains(err.Error(), "revoked")
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package internal

import (
        "fmt"
        "os"
        "regexp"

        "github.com/Masterminds/semver/v3"
        "gopkg.in/yaml.v3"
)

// BotConfig represents the bot configuration structure
type BotConfig struct {
        Name        string `yaml:"name" json:"name"`
        Description string `yaml:"description" json:"description"`
        Version     string `yaml:"version" json:"version"`
        Author      string `yaml:"author" json:"author"`
        Runtime     string `yaml:"runtime,omitempty" json:"runtime,omitempty"` // e.g., "python3.11", "nodejs20", defaults to "none"
        Type        string `yaml:"type" json:"type"`                           // e.g., "scheduled", "event", "realtime"
        Entrypoints struct {
                Bot      string `yaml:"bot" json:"bot"`
                Backtest string `yaml:"backtest" json:"backtest"`
        } `yaml:"entrypoints" json:"entrypoints"`
        Schema struct {
                Backtest string `yaml:"backtest" json:"backtest"`
                Bot      string `yaml:"bot" json:"bot"`
        } `yaml:"schema" json:"schema"`
        Readme   string                 `yaml:"readme" json:"readme"`
        Metadata map[string]interface{} `yaml:"metadata,omitempty" json:"metadata,omitempty"`
}

// LoadBotConfig loads and parses the bot-config.yaml file
func LoadBotConfig() (*BotConfig, error) <span class="cov0" title="0">{
        if _, err := os.Stat("bot-config.yaml"); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("bot-config.yaml not found in current directory")
        }</span>

        <span class="cov0" title="0">data, err := os.ReadFile("bot-config.yaml")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read bot-config.yaml: %v", err)
        }</span>

        <span class="cov0" title="0">var config BotConfig
        if err := yaml.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid YAML in bot-config.yaml: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

// ValidateBotConfig validates the bot configuration
func ValidateBotConfig(config *BotConfig) error <span class="cov0" title="0">{
        if config.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("bot name is required")
        }</span>

        // Validate name format (only dashes allowed)
        <span class="cov0" title="0">nameRegex := regexp.MustCompile(`^[a-z0-9-]+$`)
        if !nameRegex.MatchString(config.Name) </span><span class="cov0" title="0">{
                return fmt.Errorf("bot name must contain only lowercase letters, numbers, and dashes")
        }</span>

        <span class="cov0" title="0">if config.Version == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("version is required")
        }</span>

        // Validate semver
        <span class="cov0" title="0">if _, err := semver.NewVersion(config.Version); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid version format. Use semantic versioning (e.g., 1.0.0): %v", err)
        }</span>

        <span class="cov0" title="0">if config.Type == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("bot type is required (e.g., 'scheduled', 'realtime', 'event')")
        }</span>

        // Validate runtime requirement for realtime bots
        <span class="cov0" title="0">if config.Type == "realtime" &amp;&amp; config.Runtime == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("runtime is required for realtime bots (e.g., 'python3.11', 'nodejs20')")
        }</span>

        <span class="cov0" title="0">if config.Entrypoints.Bot == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("bot entrypoint is required")
        }</span>

        // Backtest entrypoint and schema are now optional

        <span class="cov0" title="0">if config.Schema.Bot == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("bot schema is required")
        }</span>

        <span class="cov0" title="0">if config.Readme == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("readme file is required")
        }</span>

        // Check if required files exist
        <span class="cov0" title="0">requiredFiles := []string{
                config.Entrypoints.Bot,
                config.Schema.Bot,
                config.Readme,
        }

        // Add backtest files to validation if they are specified
        if config.Entrypoints.Backtest != "" </span><span class="cov0" title="0">{
                requiredFiles = append(requiredFiles, config.Entrypoints.Backtest)
        }</span>
        <span class="cov0" title="0">if config.Schema.Backtest != "" </span><span class="cov0" title="0">{
                requiredFiles = append(requiredFiles, config.Schema.Backtest)
        }</span>

        <span class="cov0" title="0">for _, file := range requiredFiles </span><span class="cov0" title="0">{
                if _, err := os.Stat(file); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("required file not found: %s", file)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package internal

import (
        "bufio"
        "os"
        "path/filepath"
        "strings"
)

// IgnorePattern represents a single ignore pattern with its properties
type IgnorePattern struct {
        Pattern     string
        IsNegation  bool
        IsDirectory bool
}

// IgnoreParser handles parsing and matching of .the0ignore files
type IgnoreParser struct {
        patterns []IgnorePattern
}

// NewIgnoreParser creates a new ignore parser
func NewIgnoreParser() *IgnoreParser <span class="cov0" title="0">{
        return &amp;IgnoreParser{
                patterns: make([]IgnorePattern, 0),
        }
}</span>

// LoadIgnoreFile loads patterns from a .the0ignore file
func (p *IgnoreParser) LoadIgnoreFile(path string) error <span class="cov0" title="0">{
        file, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        // No ignore file is not an error
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">defer file.Close()

        scanner := bufio.NewScanner(file)
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())

                // Skip empty lines and comments
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">pattern := IgnorePattern{
                        Pattern: line,
                }

                // Check for negation
                if strings.HasPrefix(line, "!") </span><span class="cov0" title="0">{
                        pattern.IsNegation = true
                        pattern.Pattern = line[1:]
                }</span>

                // Check for directory-only pattern
                <span class="cov0" title="0">if strings.HasSuffix(pattern.Pattern, "/") </span><span class="cov0" title="0">{
                        pattern.IsDirectory = true
                        pattern.Pattern = strings.TrimSuffix(pattern.Pattern, "/")
                }</span>

                <span class="cov0" title="0">p.patterns = append(p.patterns, pattern)</span>
        }

        <span class="cov0" title="0">return scanner.Err()</span>
}

// AddDefaultPatterns adds default ignore patterns
func (p *IgnoreParser) AddDefaultPatterns() <span class="cov0" title="0">{
        defaults := []string{
                "*.log", "*.tmp", "*.temp",
                "test/", "tests/", "__tests__/",
                ".DS_Store", "Thumbs.db",
                "*.pyc", "*.pyo",
                "__pycache__/",
                ".git/",
                "build/", "dist/",
        }

        for _, pattern := range defaults </span><span class="cov0" title="0">{
                ignorePattern := IgnorePattern{
                        Pattern: pattern,
                }

                if strings.HasSuffix(pattern, "/") </span><span class="cov0" title="0">{
                        ignorePattern.IsDirectory = true
                        ignorePattern.Pattern = strings.TrimSuffix(pattern, "/")
                }</span>

                <span class="cov0" title="0">p.patterns = append(p.patterns, ignorePattern)</span>
        }
}

// IsIgnored checks if a file path should be ignored
func (p *IgnoreParser) IsIgnored(relPath string, isDir bool) bool <span class="cov0" title="0">{
        // Never ignore vendor or node_modules directories (they are explicitly protected)
        if relPath == "vendor" || relPath == "node_modules" ||
                strings.HasPrefix(relPath, "vendor/") || strings.HasPrefix(relPath, "node_modules/") </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">ignored := false

        // Process patterns in order
        for _, pattern := range p.patterns </span><span class="cov0" title="0">{
                matched := p.matchPattern(pattern.Pattern, relPath, isDir)

                if matched </span><span class="cov0" title="0">{
                        if pattern.IsNegation </span><span class="cov0" title="0">{
                                ignored = false
                        }</span> else<span class="cov0" title="0"> {
                                ignored = true
                        }</span>
                }
        }

        <span class="cov0" title="0">return ignored</span>
}

// matchPattern performs pattern matching similar to gitignore
func (p *IgnoreParser) matchPattern(pattern, path string, isDir bool) bool <span class="cov0" title="0">{
        // Handle ** patterns first (match any depth)
        if strings.Contains(pattern, "**") </span><span class="cov0" title="0">{
                return p.matchDoubleStarPattern(pattern, path, isDir)
        }</span>

        // Handle directory patterns - if pattern ends with /, it applies to directories and their contents
        <span class="cov0" title="0">isDirectoryPattern := strings.HasSuffix(pattern, "/")
        if isDirectoryPattern </span><span class="cov0" title="0">{
                pattern = strings.TrimSuffix(pattern, "/")
        }</span>

        // Exact match
        <span class="cov0" title="0">if pattern == path || pattern == filepath.Base(path) </span><span class="cov0" title="0">{
                return true
        }</span>

        // For directory patterns, check if the path is under that directory
        <span class="cov0" title="0">if isDirectoryPattern </span><span class="cov0" title="0">{
                // Pattern "test/" should match "test/file.py", "test/subdir/file.py", etc.
                if strings.HasPrefix(path, pattern+"/") </span><span class="cov0" title="0">{
                        return true
                }</span>
                // For the directory itself, check exact match
                <span class="cov0" title="0">if path == pattern &amp;&amp; isDir </span><span class="cov0" title="0">{
                        return true
                }</span>
                // Also check if any directory in the path matches (for nested cases)
                <span class="cov0" title="0">pathParts := strings.Split(path, string(filepath.Separator))
                for _, part := range pathParts </span><span class="cov0" title="0">{
                        if pattern == part </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        // Handle glob patterns
        <span class="cov0" title="0">if strings.Contains(pattern, "*") </span><span class="cov0" title="0">{
                // Try matching against the full relative path
                matched, _ := filepath.Match(pattern, path)
                if matched </span><span class="cov0" title="0">{
                        return true
                }</span>

                // Try matching against the base name
                <span class="cov0" title="0">matched, _ = filepath.Match(pattern, filepath.Base(path))
                if matched </span><span class="cov0" title="0">{
                        return true
                }</span>

                // For non-directory patterns, also check each path component
                <span class="cov0" title="0">if !isDirectoryPattern </span><span class="cov0" title="0">{
                        pathParts := strings.Split(path, string(filepath.Separator))
                        for _, part := range pathParts </span><span class="cov0" title="0">{
                                matched, _ := filepath.Match(pattern, part)
                                if matched </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                }
        }

        // Check if the path starts with the pattern (for simple directory matching)
        <span class="cov0" title="0">if strings.HasPrefix(path, pattern+"/") </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// matchDoubleStarPattern handles ** patterns specifically
func (p *IgnoreParser) matchDoubleStarPattern(pattern, path string, isDir bool) bool <span class="cov0" title="0">{
        // Split pattern by **
        parts := strings.Split(pattern, "**")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">prefix := strings.TrimSuffix(parts[0], "/")
        suffix := strings.TrimPrefix(parts[1], "/")

        // Check if path starts with prefix
        if prefix != "" </span><span class="cov0" title="0">{
                if !strings.HasPrefix(path, prefix) &amp;&amp; !strings.HasPrefix(path, prefix+"/") </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // If no suffix, match everything under prefix
        <span class="cov0" title="0">if suffix == "" </span><span class="cov0" title="0">{
                return true
        }</span>

        // Extract the part after the prefix
        <span class="cov0" title="0">remainingPath := path
        if prefix != "" </span><span class="cov0" title="0">{
                if strings.HasPrefix(path, prefix+"/") </span><span class="cov0" title="0">{
                        remainingPath = strings.TrimPrefix(path, prefix+"/")
                }</span> else<span class="cov0" title="0"> if path == prefix </span><span class="cov0" title="0">{
                        remainingPath = ""
                }</span> else<span class="cov0" title="0"> {
                        return false
                }</span>
        }

        // Handle suffix matching
        <span class="cov0" title="0">if strings.Contains(suffix, "*") </span><span class="cov0" title="0">{
                // Check if remaining path matches the suffix pattern
                matched, _ := filepath.Match(suffix, remainingPath)
                if matched </span><span class="cov0" title="0">{
                        return true
                }</span>

                // Also check if any directory component matches
                <span class="cov0" title="0">pathParts := strings.Split(remainingPath, string(filepath.Separator))
                for i := range pathParts </span><span class="cov0" title="0">{
                        subPath := strings.Join(pathParts[i:], string(filepath.Separator))
                        matched, _ := filepath.Match(suffix, subPath)
                        if matched </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }

                // Check if base name matches
                <span class="cov0" title="0">matched, _ = filepath.Match(suffix, filepath.Base(remainingPath))
                if matched </span><span class="cov0" title="0">{
                        return true
                }</span>
        } else<span class="cov0" title="0"> {
                // Handle directory suffix
                if strings.HasSuffix(suffix, "/") </span><span class="cov0" title="0">{
                        suffix = strings.TrimSuffix(suffix, "/")
                        if !isDir </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }

                // Simple suffix match
                <span class="cov0" title="0">if remainingPath == suffix || strings.HasSuffix(remainingPath, "/"+suffix) </span><span class="cov0" title="0">{
                        return true
                }</span>

                // Check if any part of the remaining path matches
                <span class="cov0" title="0">pathParts := strings.Split(remainingPath, string(filepath.Separator))
                for _, part := range pathParts </span><span class="cov0" title="0">{
                        if part == suffix </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov0" title="0">return false</span>
}

// CreateIgnoreParserForDir creates an ignore parser for a specific directory
func CreateIgnoreParserForDir(dir string) (*IgnoreParser, error) <span class="cov0" title="0">{
        parser := NewIgnoreParser()

        // Add default patterns first
        parser.AddDefaultPatterns()

        // Load .the0ignore file if it exists
        ignoreFilePath := filepath.Join(dir, ".the0ignore")
        if err := parser.LoadIgnoreFile(ignoreFilePath); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return parser, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package internal

import (
        "bytes"
        "context"
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "os"
        "runtime"
        "strings"
        "time"
)

// UpdateChannel represents the update channel
type UpdateChannel string

const (
        ProductionChannel UpdateChannel = "production"
        StagingChannel    UpdateChannel = "staging"
)

// ReleaseInfo represents a single release version
type ReleaseInfo struct {
        Version     string    `json:"version"`
        Branch      string    `json:"branch"`
        Commit      string    `json:"commit"`
        Date        time.Time `json:"date"`
        Environment string    `json:"environment"`
        Platforms   []string  `json:"platforms"`
}

// VersionManifest represents the version manifest structure
type VersionManifest struct {
        Versions []ReleaseInfo `json:"versions"`
}

// PlatformInfo contains platform-specific information
type PlatformInfo struct {
        OS          string // runtime.GOOS
        Arch        string // runtime.GOARCH
        BinaryName  string // the0-darwin-arm64 or the0-windows-amd64.exe
        DownloadURL string // Full GCS URL for binary
        ChecksumURL string // URL for SHA256 checksum file
}

// UpdateConfig contains configuration for the updater
type UpdateConfig struct {
        Channel         UpdateChannel
        CurrentVersion  string
        CheckTimeout    time.Duration
        DownloadTimeout time.Duration
        BaseURL         string
}

// ProgressWriter tracks download progress
type ProgressWriter struct {
        Total    int64
        Written  int64
        OnUpdate func(written, total int64)
}

func (pw *ProgressWriter) Write(p []byte) (int, error) <span class="cov0" title="0">{
        n := len(p)
        pw.Written += int64(n)
        if pw.OnUpdate != nil </span><span class="cov0" title="0">{
                pw.OnUpdate(pw.Written, pw.Total)
        }</span>
        <span class="cov0" title="0">return n, nil</span>
}

// Updater handles the update process
type Updater struct {
        config       UpdateConfig
        platformInfo *PlatformInfo
        httpClient   *http.Client
}

// NewUpdater creates a new updater instance
func NewUpdater(config UpdateConfig) *Updater <span class="cov0" title="0">{
        // Set default timeouts if not provided
        if config.CheckTimeout == 0 </span><span class="cov0" title="0">{
                config.CheckTimeout = 10 * time.Second
        }</span>
        <span class="cov0" title="0">if config.DownloadTimeout == 0 </span><span class="cov0" title="0">{
                config.DownloadTimeout = 5 * time.Minute
        }</span>

        // Set base URL if not provided
        <span class="cov0" title="0">if config.BaseURL == "" </span><span class="cov0" title="0">{
                config.BaseURL = "https://storage.googleapis.com/the0-cli-releases"
                if config.Channel == StagingChannel </span><span class="cov0" title="0">{
                        config.BaseURL = "https://storage.googleapis.com/the0-cli-releases-staging"
                }</span>
        }

        // Create platform info with custom base URL
        <span class="cov0" title="0">platformInfo := GetPlatformInfo(config.Channel)
        if config.BaseURL != "" </span><span class="cov0" title="0">{
                // Override URLs with custom base URL
                platformInfo.DownloadURL = fmt.Sprintf("%s/latest/%s", config.BaseURL, platformInfo.BinaryName)
                platformInfo.ChecksumURL = fmt.Sprintf("%s/latest/checksums.txt", config.BaseURL)
        }</span>

        <span class="cov0" title="0">return &amp;Updater{
                config:       config,
                platformInfo: platformInfo,
                httpClient: &amp;http.Client{
                        Timeout: config.CheckTimeout,
                },
        }</span>
}

// GetPlatformInfo returns platform-specific information
func GetPlatformInfo(channel UpdateChannel) *PlatformInfo <span class="cov0" title="0">{
        goos := runtime.GOOS
        goarch := runtime.GOARCH

        // Binary naming matches GitHub Actions workflow
        binaryName := fmt.Sprintf("the0-%s-%s", goos, goarch)
        if goos == "windows" </span><span class="cov0" title="0">{
                binaryName += ".exe"
        }</span>

        // URL construction matches GCS bucket structure
        <span class="cov0" title="0">baseURL := "https://storage.googleapis.com/the0-cli-releases"
        if channel == StagingChannel </span><span class="cov0" title="0">{
                baseURL += "-staging"
        }</span>

        <span class="cov0" title="0">return &amp;PlatformInfo{
                OS:          goos,
                Arch:        goarch,
                BinaryName:  binaryName,
                DownloadURL: fmt.Sprintf("%s/latest/%s", baseURL, binaryName),
                ChecksumURL: fmt.Sprintf("%s/latest/checksums.txt", baseURL),
        }</span>
}

// GetUpdateChannel returns the update channel from environment variable
func GetUpdateChannel() UpdateChannel <span class="cov0" title="0">{
        channel := os.Getenv("THE0_CLI_UPDATE_CHANNEL")
        if channel == "staging" </span><span class="cov0" title="0">{
                return StagingChannel
        }</span>
        <span class="cov0" title="0">return ProductionChannel</span>
}

// FetchVersionManifest fetches the version manifest from GCS
func (u *Updater) FetchVersionManifest(ctx context.Context) (*VersionManifest, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/versions.json", u.config.BaseURL)

        req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        // Add cache-busting headers to ensure fresh data
        <span class="cov0" title="0">req.Header.Set("Cache-Control", "no-cache")
        req.Header.Set("Pragma", "no-cache")

        // Add timestamp to query string for additional cache busting
        if strings.Contains(url, "?") </span><span class="cov0" title="0">{
                url += "&amp;"
        }</span> else<span class="cov0" title="0"> {
                url += "?"
        }</span>
        <span class="cov0" title="0">url += fmt.Sprintf("t=%d", time.Now().Unix())

        // Recreate request with cache-busted URL
        req, err = http.NewRequestWithContext(ctx, "GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Cache-Control", "no-cache")
        req.Header.Set("Pragma", "no-cache")

        resp, err := u.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch version manifest: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("version manifest request failed: HTTP %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var manifest VersionManifest
        if err := json.NewDecoder(resp.Body).Decode(&amp;manifest); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode version manifest: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;manifest, nil</span>
}

// CheckForUpdates checks if an update is available
func (u *Updater) CheckForUpdates(ctx context.Context) (bool, string, error) <span class="cov0" title="0">{
        manifest, err := u.FetchVersionManifest(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return false, "", err
        }</span>

        <span class="cov0" title="0">if len(manifest.Versions) == 0 </span><span class="cov0" title="0">{
                return false, "", fmt.Errorf("no versions found in manifest")
        }</span>

        // Get the latest version (first in the list)
        <span class="cov0" title="0">latestVersion := manifest.Versions[0].Version

        // Check if our platform is supported
        // Extract platform part from binary name (remove "the0-" prefix)
        currentPlatform := strings.TrimPrefix(u.platformInfo.BinaryName, "the0-")
        // Remove .exe suffix if present
        currentPlatform = strings.TrimSuffix(currentPlatform, ".exe")

        platformSupported := false
        for _, platform := range manifest.Versions[0].Platforms </span><span class="cov0" title="0">{
                if platform == currentPlatform </span><span class="cov0" title="0">{
                        platformSupported = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !platformSupported </span><span class="cov0" title="0">{
                return false, "", fmt.Errorf("current platform (%s) not supported in latest version", u.platformInfo.BinaryName)
        }</span>

        // Compare versions
        <span class="cov0" title="0">updateAvailable, err := CompareVersions(u.config.CurrentVersion, latestVersion)
        if err != nil </span><span class="cov0" title="0">{
                return false, "", fmt.Errorf("failed to compare versions: %w", err)
        }</span>

        <span class="cov0" title="0">return updateAvailable, latestVersion, nil</span>
}

// DownloadBinary downloads the binary with progress indication
func (u *Updater) DownloadBinary(ctx context.Context, progressCallback func(int64, int64)) ([]byte, error) <span class="cov0" title="0">{
        // Use extended timeout for downloads
        client := &amp;http.Client{
                Timeout: u.config.DownloadTimeout,
        }

        req, err := http.NewRequestWithContext(ctx, "GET", u.platformInfo.DownloadURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create download request: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("download failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("download failed: HTTP %d", resp.StatusCode)
        }</span>

        // Progress indication using io.TeeReader
        <span class="cov0" title="0">var buf bytes.Buffer
        progressWriter := &amp;ProgressWriter{
                Total:    resp.ContentLength,
                OnUpdate: progressCallback,
        }

        _, err = io.Copy(&amp;buf, io.TeeReader(resp.Body, progressWriter))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to download binary: %w", err)
        }</span>

        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

// VerifyChecksum verifies the downloaded binary checksum
func (u *Updater) VerifyChecksum(ctx context.Context, binaryData []byte) error <span class="cov0" title="0">{
        // Download checksums file
        client := &amp;http.Client{
                Timeout: u.config.CheckTimeout,
        }

        req, err := http.NewRequestWithContext(ctx, "GET", u.platformInfo.ChecksumURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create checksum request: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to download checksums: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                return fmt.Errorf("checksum download failed: HTTP %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">checksumData, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read checksums: %w", err)
        }</span>

        // Parse checksums file to find our binary
        <span class="cov0" title="0">checksumLines := strings.Split(string(checksumData), "\n")
        var expectedChecksum string

        for _, line := range checksumLines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">parts := strings.Fields(line)
                if len(parts) &gt;= 2 </span><span class="cov0" title="0">{
                        checksum := parts[0]
                        filename := parts[1]
                        if filename == u.platformInfo.BinaryName </span><span class="cov0" title="0">{
                                expectedChecksum = checksum
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">if expectedChecksum == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("checksum not found for binary: %s", u.platformInfo.BinaryName)
        }</span>

        // Calculate actual checksum
        <span class="cov0" title="0">hash := sha256.Sum256(binaryData)
        actualChecksum := hex.EncodeToString(hash[:])

        if actualChecksum != expectedChecksum </span><span class="cov0" title="0">{
                return fmt.Errorf("checksum mismatch: expected %s, got %s", expectedChecksum, actualChecksum)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ReplaceBinary replaces the current binary with the new one
func (u *Updater) ReplaceBinary(newBinaryData []byte) error <span class="cov0" title="0">{
        currentExePath, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get current executable path: %w", err)
        }</span>

        <span class="cov0" title="0">if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                // Windows file lock handling via rename strategy
                return u.replaceBinaryWindows(currentExePath, newBinaryData)
        }</span>

        <span class="cov0" title="0">return u.replaceBinaryUnix(currentExePath, newBinaryData)</span>
}

// replaceBinaryWindows handles Windows-specific binary replacement
func (u *Updater) replaceBinaryWindows(currentPath string, newData []byte) error <span class="cov0" title="0">{
        // Create temporary file for new binary
        tempPath := currentPath + ".new"
        if err := os.WriteFile(tempPath, newData, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write new binary: %w", err)
        }</span>

        // Rename current binary (works even if file is locked)
        <span class="cov0" title="0">oldPath := currentPath + ".old"
        if err := os.Rename(currentPath, oldPath); err != nil </span><span class="cov0" title="0">{
                os.Remove(tempPath) // Cleanup
                return fmt.Errorf("failed to rename current binary: %w", err)
        }</span>

        // Rename new binary to current name
        <span class="cov0" title="0">if err := os.Rename(tempPath, currentPath); err != nil </span><span class="cov0" title="0">{
                os.Rename(oldPath, currentPath) // Rollback
                return fmt.Errorf("failed to install new binary: %w", err)
        }</span>

        // Cleanup old binary (may fail if still locked, that's ok)
        <span class="cov0" title="0">os.Remove(oldPath)

        return nil</span>
}

// replaceBinaryUnix handles Unix-specific binary replacement
func (u *Updater) replaceBinaryUnix(currentPath string, newData []byte) error <span class="cov0" title="0">{
        // Atomic replacement with permission preservation
        stat, err := os.Stat(currentPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stat current binary: %w", err)
        }</span>

        // Create temporary file in same directory for atomic move
        <span class="cov0" title="0">tempPath := currentPath + ".new"
        if err := os.WriteFile(tempPath, newData, stat.Mode()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write new binary: %w", err)
        }</span>

        // Atomic replacement
        <span class="cov0" title="0">if err := os.Rename(tempPath, currentPath); err != nil </span><span class="cov0" title="0">{
                os.Remove(tempPath) // Cleanup
                return fmt.Errorf("failed to replace binary: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// SelfUpdate performs a complete self-update
func (u *Updater) SelfUpdate(ctx context.Context, progressCallback func(int64, int64)) error <span class="cov0" title="0">{
        // Check for updates first
        updateAvailable, latestVersion, err := u.CheckForUpdates(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check for updates: %w", err)
        }</span>

        <span class="cov0" title="0">if !updateAvailable </span><span class="cov0" title="0">{
                return fmt.Errorf("no update available")
        }</span>

        // Download binary
        <span class="cov0" title="0">binaryData, err := u.DownloadBinary(ctx, progressCallback)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to download binary: %w", err)
        }</span>

        // Verify checksum
        <span class="cov0" title="0">if err := u.VerifyChecksum(ctx, binaryData); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to verify checksum: %w", err)
        }</span>

        // Replace binary
        <span class="cov0" title="0">if err := u.ReplaceBinary(binaryData); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to replace binary: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("‚úÖ Successfully updated to version %s\n", latestVersion)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package internal

import (
        "context"
        "fmt"
        "io"
        "os"
        "os/exec"
        "os/user"
        "path/filepath"
        "strings"
        "time"

        "github.com/docker/docker/api/types/container"
        "github.com/docker/docker/api/types/image"
        "github.com/docker/docker/client"
        "github.com/fatih/color"
)

const (
        pythonImage          = "python:3.11-slim"
        nodeImage            = "node:20-slim"
        vendorDir            = "vendor"
        nodeModulesDir       = "node_modules"
        nodeModulesBackupDir = "_node_modules_backup"
        containerName        = "the0-vendor-"
)

// VendorManager handles Docker-based package vendoring
type VendorManager struct {
        dockerClient *client.Client
        projectPath  string
}

// NewVendorManager creates a new vendor manager instance
func NewVendorManager(projectPath string) (*VendorManager, error) <span class="cov0" title="0">{
        cli, err := client.NewClientWithOpts(client.FromEnv, client.WithAPIVersionNegotiation())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Docker client: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;VendorManager{
                dockerClient: cli,
                projectPath:  projectPath,
        }, nil</span>
}

// CheckDockerInstalled verifies if Docker is installed and accessible
func CheckDockerInstalled() error <span class="cov0" title="0">{
        cmd := exec.Command("docker", "--version")
        err := cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Docker is not installed or not accessible. Please install Docker and ensure it's in your PATH")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CheckDockerRunning verifies if Docker daemon is running
func (vm *VendorManager) CheckDockerRunning() error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        _, err := vm.dockerClient.Ping(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Docker daemon is not running. Please start Docker and try again")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CheckRequirementsFile checks if requirements.txt exists in the project
func (vm *VendorManager) CheckRequirementsFile() bool <span class="cov0" title="0">{
        requirementsPath := filepath.Join(vm.projectPath, "requirements.txt")
        _, err := os.Stat(requirementsPath)
        return err == nil
}</span>

// CheckPackageJsonFile checks if package.json exists in the project
func (vm *VendorManager) CheckPackageJsonFile() bool <span class="cov0" title="0">{
        packageJsonPath := filepath.Join(vm.projectPath, "package.json")
        _, err := os.Stat(packageJsonPath)
        return err == nil
}</span>

// CheckTypeScriptFiles checks if TypeScript files exist in the project
func (vm *VendorManager) CheckTypeScriptFiles() bool <span class="cov0" title="0">{
        files, err := filepath.Glob(filepath.Join(vm.projectPath, "*.ts"))
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return len(files) &gt; 0</span>
}

// PerformVendoring performs the complete Python vendoring process
func (vm *VendorManager) PerformVendoring() error <span class="cov0" title="0">{
        blue := color.New(color.FgBlue)
        green := color.New(color.FgGreen)

        blue.Println("üîÆ Installing Python dependencies...")

        // Step 1: Pull Python image if needed
        if err := vm.pullPythonImage(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to pull Python image: %v", err)
        }</span>

        // Step 2: Create vendor directory
        <span class="cov0" title="0">vendorPath := filepath.Join(vm.projectPath, vendorDir)
        if err := os.RemoveAll(vendorPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to clean vendor directory: %v", err)
        }</span>
        <span class="cov0" title="0">if err := os.MkdirAll(vendorPath, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create vendor directory: %v", err)
        }</span>

        // Step 3: Run vendoring container
        <span class="cov0" title="0">containerID, err := vm.runVendorContainer()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to run vendoring container: %v", err)
        }</span>
        <span class="cov0" title="0">defer vm.cleanupContainer(containerID)

        // Step 4: Verify vendored files
        if err := vm.verifyVendoredFiles(vendorPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to verify vendored files: %v", err)
        }</span>

        <span class="cov0" title="0">green.Println("‚úì Python dependencies installed successfully ‚ö°")
        return nil</span>
}

// PerformNodeVendoring performs Node.js package vendoring
func (vm *VendorManager) PerformNodeVendoring(hasTypeScript bool) error <span class="cov0" title="0">{
        blue := color.New(color.FgBlue)
        green := color.New(color.FgGreen)

        blue.Println("‚ö° Installing JavaScript dependencies...")

        // Step 1: Pull Node image if needed
        if err := vm.pullNodeImage(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to pull Node image: %v", err)
        }</span>

        // Step 1.5: Backup existing node_modules if it exists
        <span class="cov0" title="0">if err := vm.backupExistingNodeModules(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to backup existing node_modules: %v", err)
        }</span>

        // Ensure backup is restored on any failure after this point
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        vm.restoreNodeModulesBackup()
                        panic(r)</span>
                }
        }()

        // Step 2: Create node_modules directory
        <span class="cov0" title="0">nodeModulesPath := filepath.Join(vm.projectPath, nodeModulesDir)
        if err := os.MkdirAll(nodeModulesPath, 0755); err != nil </span><span class="cov0" title="0">{
                vm.restoreNodeModulesBackup()
                return fmt.Errorf("failed to create node_modules directory: %v", err)
        }</span>

        // Step 3: Run vendoring container
        <span class="cov0" title="0">containerID, err := vm.runNodeVendorContainer(hasTypeScript)
        if err != nil </span><span class="cov0" title="0">{
                vm.restoreNodeModulesBackup()
                return fmt.Errorf("failed to run Node vendoring container: %v", err)
        }</span>
        <span class="cov0" title="0">defer vm.cleanupContainer(containerID)

        // Step 4: Verify vendored files
        if err := vm.verifyVendoredFiles(nodeModulesPath); err != nil </span><span class="cov0" title="0">{
                vm.restoreNodeModulesBackup()
                return fmt.Errorf("failed to verify vendored files: %v", err)
        }</span>

        // Step 5: Cleanup backup on success
        <span class="cov0" title="0">if err := vm.cleanupNodeModulesBackup(); err != nil </span><span class="cov0" title="0">{
                // Log warning but don't fail - vendoring was successful
                yellow := color.New(color.FgYellow)
                yellow.Printf("‚ö†Ô∏è Warning: failed to cleanup node_modules backup: %v\n", err)
        }</span>

        <span class="cov0" title="0">green.Println("‚úì JavaScript dependencies installed successfully ‚ö°")
        return nil</span>
}

// pullPythonImage pulls the Python image if it doesn't exist locally
func (vm *VendorManager) pullPythonImage() error <span class="cov0" title="0">{
        ctx := context.Background()

        // Check if image exists locally
        images, err := vm.dockerClient.ImageList(ctx, image.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">imageExists := false
        for _, img := range images </span><span class="cov0" title="0">{
                for _, tag := range img.RepoTags </span><span class="cov0" title="0">{
                        if tag == pythonImage </span><span class="cov0" title="0">{
                                imageExists = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if imageExists </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">if imageExists </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">blue := color.New(color.FgBlue)
        blue.Printf("üì• Downloading Python trading engine: %s...\n", pythonImage)

        reader, err := vm.dockerClient.ImagePull(ctx, pythonImage, image.PullOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer reader.Close()

        // Read pull output (but don't display it to keep output clean)
        io.Copy(io.Discard, reader)

        return nil</span>
}

// pullNodeImage pulls the Node.js image if it doesn't exist locally
func (vm *VendorManager) pullNodeImage() error <span class="cov0" title="0">{
        ctx := context.Background()

        // Check if image exists locally
        images, err := vm.dockerClient.ImageList(ctx, image.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">imageExists := false
        for _, img := range images </span><span class="cov0" title="0">{
                for _, tag := range img.RepoTags </span><span class="cov0" title="0">{
                        if tag == nodeImage </span><span class="cov0" title="0">{
                                imageExists = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if imageExists </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">if imageExists </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">blue := color.New(color.FgBlue)
        blue.Printf("üì• Downloading JavaScript trading engine: %s...\n", nodeImage)

        reader, err := vm.dockerClient.ImagePull(ctx, nodeImage, image.PullOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer reader.Close()

        // Read pull output (but don't display it to keep output clean)
        io.Copy(io.Discard, reader)

        return nil</span>
}

// runVendorContainer creates and runs a container for Python vendoring
func (vm *VendorManager) runVendorContainer() (string, error) <span class="cov0" title="0">{
        ctx := context.Background()

        // Generate unique container name
        containerName := fmt.Sprintf("%s%d", containerName, time.Now().Unix())

        // Prepare absolute paths for volume mounting
        vendorPath := filepath.Join(vm.projectPath, vendorDir)
        requirementsPath := filepath.Join(vm.projectPath, "requirements.txt")

        absVendorPath, err := filepath.Abs(vendorPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get absolute vendor path: %v", err)
        }</span>

        <span class="cov0" title="0">absRequirementsPath, err := filepath.Abs(requirementsPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get absolute requirements path: %v", err)
        }</span>

        <span class="cov0" title="0">config := &amp;container.Config{
                Image: pythonImage,
                Cmd: []string{
                        "sh", "-c",
                        vm.getPythonInstallCommand(),
                },
                WorkingDir: "/app",
        }

        hostConfig := &amp;container.HostConfig{
                Binds: []string{
                        fmt.Sprintf("%s:/vendor", absVendorPath),
                        fmt.Sprintf("%s:/requirements.txt:ro", absRequirementsPath),
                },
                AutoRemove: false, // We'll remove manually after copying files
        }

        resp, err := vm.dockerClient.ContainerCreate(ctx, config, hostConfig, nil, nil, containerName)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if err := vm.dockerClient.ContainerStart(ctx, resp.ID, container.StartOptions{}); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Stream logs in real-time while container is running
        <span class="cov0" title="0">logReader, err := vm.dockerClient.ContainerLogs(ctx, resp.ID, container.LogsOptions{
                ShowStdout: true,
                ShowStderr: true,
                Follow:     true,
                Timestamps: false,
        })
        if err != nil </span><span class="cov0" title="0">{
                return resp.ID, fmt.Errorf("failed to get container logs: %v", err)
        }</span>

        // Stream logs in a goroutine
        <span class="cov0" title="0">logDone := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                defer close(logDone)
                defer logReader.Close()

                blue := color.New(color.FgBlue)
                buffer := make([]byte, 1024)
                for </span><span class="cov0" title="0">{
                        n, err := logReader.Read(buffer)
                        if err != nil </span><span class="cov0" title="0">{
                                if err != io.EOF </span><span class="cov0" title="0">{
                                        blue.Printf("Log read error: %v\n", err)
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }

                        <span class="cov0" title="0">if n &gt; 0 </span><span class="cov0" title="0">{
                                // Clean Docker log headers and display output
                                output := vm.cleanDockerLogOutput(buffer[:n])
                                if output != "" </span><span class="cov0" title="0">{
                                        blue.Printf("üîÆ %s", output)
                                }</span>
                        }
                }
        }()

        // Wait for container to finish
        <span class="cov0" title="0">statusCh, errCh := vm.dockerClient.ContainerWait(ctx, resp.ID, container.WaitConditionNotRunning)
        select </span>{
        case err := &lt;-errCh:<span class="cov0" title="0">
                if err != nil </span><span class="cov0" title="0">{
                        return resp.ID, err
                }</span>
        case status := &lt;-statusCh:<span class="cov0" title="0">
                // Wait for logs to finish streaming
                &lt;-logDone

                if status.StatusCode != 0 </span><span class="cov0" title="0">{
                        // Get full container logs for error details
                        logs, _ := vm.getContainerLogs(resp.ID)
                        red := color.New(color.FgRed)
                        red.Printf("‚ö†Ô∏è Python dependency installation failed with exit code %d\n", status.StatusCode)
                        if logs != "" </span><span class="cov0" title="0">{
                                red.Printf("üìã Full error log:\n%s\n", logs)
                        }</span>
                        <span class="cov0" title="0">return resp.ID, fmt.Errorf("pip install failed with exit code %d", status.StatusCode)</span>
                }
        }

        <span class="cov0" title="0">return resp.ID, nil</span>
}

// runNodeVendorContainer creates and runs a container for Node.js vendoring
func (vm *VendorManager) runNodeVendorContainer(hasTypeScript bool) (string, error) <span class="cov0" title="0">{
        ctx := context.Background()

        // Generate unique container name
        containerName := fmt.Sprintf("%snode-%d", containerName, time.Now().Unix())

        // Prepare absolute paths for volume mounting
        nodeModulesPath := filepath.Join(vm.projectPath, nodeModulesDir)
        packageJsonPath := filepath.Join(vm.projectPath, "package.json")

        absNodeModulesPath, err := filepath.Abs(nodeModulesPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get absolute node_modules path: %v", err)
        }</span>

        <span class="cov0" title="0">absPackageJsonPath, err := filepath.Abs(packageJsonPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get absolute package.json path: %v", err)
        }</span>

        // Build install command
        <span class="cov0" title="0">installCmd := vm.getNodeInstallCommand(hasTypeScript)

        config := &amp;container.Config{
                Image: nodeImage,
                Cmd: []string{
                        "sh", "-c",
                        installCmd,
                },
                WorkingDir: "/app",
        }

        hostConfig := &amp;container.HostConfig{
                Binds: []string{
                        fmt.Sprintf("%s:/app/node_modules", absNodeModulesPath),
                        fmt.Sprintf("%s:/app/package.json:ro", absPackageJsonPath),
                },
                AutoRemove: false, // We'll remove manually after copying files
        }

        resp, err := vm.dockerClient.ContainerCreate(ctx, config, hostConfig, nil, nil, containerName)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if err := vm.dockerClient.ContainerStart(ctx, resp.ID, container.StartOptions{}); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Stream logs in real-time while container is running
        <span class="cov0" title="0">logReader, err := vm.dockerClient.ContainerLogs(ctx, resp.ID, container.LogsOptions{
                ShowStdout: true,
                ShowStderr: true,
                Follow:     true,
                Timestamps: false,
        })
        if err != nil </span><span class="cov0" title="0">{
                return resp.ID, fmt.Errorf("failed to get container logs: %v", err)
        }</span>

        // Stream logs in a goroutine
        <span class="cov0" title="0">logDone := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                defer close(logDone)
                defer logReader.Close()

                green := color.New(color.FgGreen)
                buffer := make([]byte, 1024)
                for </span><span class="cov0" title="0">{
                        n, err := logReader.Read(buffer)
                        if err != nil </span><span class="cov0" title="0">{
                                if err != io.EOF </span><span class="cov0" title="0">{
                                        green.Printf("Log read error: %v\n", err)
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }

                        <span class="cov0" title="0">if n &gt; 0 </span><span class="cov0" title="0">{
                                // Clean Docker log headers and display output
                                output := vm.cleanDockerLogOutput(buffer[:n])
                                if output != "" </span><span class="cov0" title="0">{
                                        green.Printf("‚ö° %s", output)
                                }</span>
                        }
                }
        }()

        // Wait for container to finish
        <span class="cov0" title="0">statusCh, errCh := vm.dockerClient.ContainerWait(ctx, resp.ID, container.WaitConditionNotRunning)
        select </span>{
        case err := &lt;-errCh:<span class="cov0" title="0">
                if err != nil </span><span class="cov0" title="0">{
                        return resp.ID, err
                }</span>
        case status := &lt;-statusCh:<span class="cov0" title="0">
                // Wait for logs to finish streaming
                &lt;-logDone

                if status.StatusCode != 0 </span><span class="cov0" title="0">{
                        // Get full container logs for error details
                        logs, _ := vm.getContainerLogs(resp.ID)
                        red := color.New(color.FgRed)
                        red.Printf("‚ö†Ô∏è JavaScript dependency installation failed with exit code %d\n", status.StatusCode)
                        if logs != "" </span><span class="cov0" title="0">{
                                red.Printf("üìã Full error log:\n%s\n", logs)
                        }</span>
                        <span class="cov0" title="0">return resp.ID, fmt.Errorf("npm install failed with exit code %d", status.StatusCode)</span>
                }
        }

        <span class="cov0" title="0">return resp.ID, nil</span>
}

// getPythonInstallCommand returns the pip install command with proper ownership
func (vm *VendorManager) getPythonInstallCommand() string <span class="cov0" title="0">{
        // Get current user info for ownership
        currentUser, err := user.Current()
        var uid, gid string
        if err == nil </span><span class="cov0" title="0">{
                uid = currentUser.Uid
                gid = currentUser.Gid
        }</span> else<span class="cov0" title="0"> {
                // Fallback to common non-root user
                uid = "1000"
                gid = "1000"
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("pip install --target /vendor -r /requirements.txt --no-cache-dir --disable-pip-version-check &amp;&amp; chown -R %s:%s /vendor", uid, gid)</span>
}

// getNodeInstallCommand returns the npm install command with proper ownership
func (vm *VendorManager) getNodeInstallCommand(hasTypeScript bool) string <span class="cov0" title="0">{
        // Get current user info for ownership
        currentUser, err := user.Current()
        var uid, gid string
        if err == nil </span><span class="cov0" title="0">{
                uid = currentUser.Uid
                gid = currentUser.Gid
        }</span> else<span class="cov0" title="0"> {
                // Fallback to common non-root user
                uid = "1000"
                gid = "1000"
        }</span>

        <span class="cov0" title="0">cmd := "npm install --production"
        if hasTypeScript </span><span class="cov0" title="0">{
                // Install dev dependencies for TypeScript compilation
                cmd = "npm install &amp;&amp; npm run build || true" // Don't fail if no build script
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%s &amp;&amp; chown -R %s:%s /app/node_modules", cmd, uid, gid)</span>
}

// verifyVendoredFiles verifies that vendoring was successful
func (vm *VendorManager) verifyVendoredFiles(vendorPath string) error <span class="cov0" title="0">{
        entries, err := os.ReadDir(vendorPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read vendor directory: %v", err)
        }</span>

        <span class="cov0" title="0">if len(entries) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no packages were vendored - check your requirements.txt file")
        }</span>

        // Calculate total size of vendored files
        <span class="cov0" title="0">totalSize, err := vm.calculateDirectorySize(vendorPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to calculate vendor directory size: %v", err)
        }</span>

        <span class="cov0" title="0">green := color.New(color.FgGreen)
        blue := color.New(color.FgBlue)

        // Convert size to human readable format
        sizeStr := vm.formatFileSize(totalSize)
        green.Printf("‚úì Successfully vendored %d packages (%s)\n", len(entries), sizeStr)

        // List key packages for verification
        blue.Println("üìã Vendored packages:")
        count := 0
        for _, entry := range entries </span><span class="cov0" title="0">{
                if count &gt;= 10 </span><span class="cov0" title="0">{ // Show max 10 packages
                        blue.Printf("   ... and %d more packages\n", len(entries)-10)
                        break</span>
                }
                <span class="cov0" title="0">if entry.IsDir() </span><span class="cov0" title="0">{
                        blue.Printf("   - %s\n", entry.Name())
                        count++
                }</span>
        }

        // Warn if the vendor directory seems unusually small
        <span class="cov0" title="0">if totalSize &lt; 1024*1024 </span><span class="cov0" title="0">{ // Less than 1MB
                yellow := color.New(color.FgYellow)
                yellow.Printf("‚ö†Ô∏è  Warning: Vendor directory is only %s - this may indicate incomplete installation\n", sizeStr)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// getContainerLogs retrieves logs from a container for debugging
func (vm *VendorManager) getContainerLogs(containerID string) (string, error) <span class="cov0" title="0">{
        ctx := context.Background()

        reader, err := vm.dockerClient.ContainerLogs(ctx, containerID, container.LogsOptions{
                ShowStdout: true,
                ShowStderr: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer reader.Close()

        logs, err := io.ReadAll(reader)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return string(logs), nil</span>
}

// cleanupContainer removes the vendoring container
func (vm *VendorManager) cleanupContainer(containerID string) <span class="cov0" title="0">{
        ctx := context.Background()
        vm.dockerClient.ContainerRemove(ctx, containerID, container.RemoveOptions{Force: true})
}</span>

// calculateDirectorySize calculates the total size of all files in a directory recursively
func (vm *VendorManager) calculateDirectorySize(dirPath string) (int64, error) <span class="cov0" title="0">{
        var totalSize int64

        err := filepath.Walk(dirPath, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if !info.IsDir() </span><span class="cov0" title="0">{
                        totalSize += info.Size()
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">return totalSize, err</span>
}

// formatFileSize formats a file size in bytes to a human-readable string
func (vm *VendorManager) formatFileSize(bytes int64) string <span class="cov0" title="0">{
        const unit = 1024
        if bytes &lt; unit </span><span class="cov0" title="0">{
                return fmt.Sprintf("%d B", bytes)
        }</span>

        <span class="cov0" title="0">div, exp := int64(unit), 0
        for n := bytes / unit; n &gt;= unit; n /= unit </span><span class="cov0" title="0">{
                div *= unit
                exp++
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%.1f %cB", float64(bytes)/float64(div), "KMGTPE"[exp])</span>
}

// cleanDockerLogOutput removes Docker log headers from raw log data
func (vm *VendorManager) cleanDockerLogOutput(logData []byte) string <span class="cov0" title="0">{
        var output strings.Builder
        i := 0

        for i &lt; len(logData) </span><span class="cov0" title="0">{
                // Docker log format: 8-byte header + message
                // Header: [stream_type][0][0][0][size_bytes_3][size_bytes_2][size_bytes_1][size_bytes_0]
                if i+8 &gt; len(logData) </span><span class="cov0" title="0">{
                        // Not enough bytes for header, append remaining
                        output.Write(logData[i:])
                        break</span>
                }

                // Extract message size from header
                <span class="cov0" title="0">size := int(logData[i+4])&lt;&lt;24 | int(logData[i+5])&lt;&lt;16 | int(logData[i+6])&lt;&lt;8 | int(logData[i+7])

                // Skip header
                i += 8

                // Extract message
                if i+size &lt;= len(logData) </span><span class="cov0" title="0">{
                        output.Write(logData[i : i+size])
                        i += size
                }</span> else<span class="cov0" title="0"> {
                        // Invalid size, append remaining
                        output.Write(logData[i:])
                        break</span>
                }
        }

        <span class="cov0" title="0">return output.String()</span>
}

// BackupExistingNodeModules creates a backup of existing node_modules directory (exported for testing)
func (vm *VendorManager) BackupExistingNodeModules() error <span class="cov0" title="0">{
        return vm.backupExistingNodeModules()
}</span>

// backupExistingNodeModules creates a backup of existing node_modules directory
func (vm *VendorManager) backupExistingNodeModules() error <span class="cov0" title="0">{
        nodeModulesPath := filepath.Join(vm.projectPath, nodeModulesDir)
        backupPath := filepath.Join(vm.projectPath, nodeModulesBackupDir)

        // Check if node_modules exists
        if _, err := os.Stat(nodeModulesPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil // No backup needed
        }</span>

        // Remove any existing backup first
        <span class="cov0" title="0">if _, err := os.Stat(backupPath); err == nil </span><span class="cov0" title="0">{
                if err := os.RemoveAll(backupPath); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to remove existing backup: %v", err)
                }</span>
        }

        // Rename node_modules to backup
        <span class="cov0" title="0">if err := os.Rename(nodeModulesPath, backupPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to backup node_modules: %v", err)
        }</span>

        <span class="cov0" title="0">blue := color.New(color.FgBlue)
        blue.Println("üì¶ Backed up existing node_modules")
        return nil</span>
}

// RestoreNodeModulesBackup restores node_modules from backup on failure (exported for testing)
func (vm *VendorManager) RestoreNodeModulesBackup() error <span class="cov0" title="0">{
        return vm.restoreNodeModulesBackup()
}</span>

// restoreNodeModulesBackup restores node_modules from backup on failure
func (vm *VendorManager) restoreNodeModulesBackup() error <span class="cov0" title="0">{
        nodeModulesPath := filepath.Join(vm.projectPath, nodeModulesDir)
        backupPath := filepath.Join(vm.projectPath, nodeModulesBackupDir)

        // Check if backup exists
        if _, err := os.Stat(backupPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil // No backup to restore
        }</span>

        // Remove failed node_modules if it exists
        <span class="cov0" title="0">if _, err := os.Stat(nodeModulesPath); err == nil </span><span class="cov0" title="0">{
                if err := os.RemoveAll(nodeModulesPath); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to remove failed node_modules: %v", err)
                }</span>
        }

        // Restore backup
        <span class="cov0" title="0">if err := os.Rename(backupPath, nodeModulesPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to restore node_modules backup: %v", err)
        }</span>

        <span class="cov0" title="0">yellow := color.New(color.FgYellow)
        yellow.Println("üîÑ Restored original node_modules")
        return nil</span>
}

// CleanupNodeModulesBackup removes backup after successful vendoring (exported for testing)
func (vm *VendorManager) CleanupNodeModulesBackup() error <span class="cov0" title="0">{
        return vm.cleanupNodeModulesBackup()
}</span>

// cleanupNodeModulesBackup removes backup after successful vendoring
func (vm *VendorManager) cleanupNodeModulesBackup() error <span class="cov0" title="0">{
        backupPath := filepath.Join(vm.projectPath, nodeModulesBackupDir)

        // Check if backup exists
        if _, err := os.Stat(backupPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil // No backup to cleanup
        }</span>

        // Remove backup
        <span class="cov0" title="0">if err := os.RemoveAll(backupPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cleanup node_modules backup: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Close closes the Docker client connection
func (vm *VendorManager) Close() error <span class="cov0" title="0">{
        if vm.dockerClient != nil </span><span class="cov0" title="0">{
                return vm.dockerClient.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ShouldPerformVendoring checks if vendoring should be performed for the current project
func ShouldPerformVendoring(projectPath string) (bool, error) <span class="cov0" title="0">{
        // Check if requirements.txt exists
        requirementsPath := filepath.Join(projectPath, "requirements.txt")
        if _, err := os.Stat(requirementsPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        // Check if vendor directory already exists and is recent
        <span class="cov0" title="0">vendorPath := filepath.Join(projectPath, vendorDir)
        vendorInfo, err := os.Stat(vendorPath)
        requirementsInfo, err2 := os.Stat(requirementsPath)

        if err == nil &amp;&amp; err2 == nil </span><span class="cov0" title="0">{
                // If vendor is newer than requirements.txt, skip vendoring
                if vendorInfo.ModTime().After(requirementsInfo.ModTime()) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }

        <span class="cov0" title="0">return true, nil</span>
}

// ShouldPerformNodeVendoring checks if Node.js vendoring should be performed
func ShouldPerformNodeVendoring(projectPath string) (bool, error) <span class="cov0" title="0">{
        // Check if package.json exists
        packageJsonPath := filepath.Join(projectPath, "package.json")
        if _, err := os.Stat(packageJsonPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        // Check if node_modules directory already exists and is recent
        <span class="cov0" title="0">nodeModulesPath := filepath.Join(projectPath, nodeModulesDir)
        nodeModulesInfo, err := os.Stat(nodeModulesPath)
        packageJsonInfo, err2 := os.Stat(packageJsonPath)

        if err == nil &amp;&amp; err2 == nil </span><span class="cov0" title="0">{
                // If node_modules is newer than package.json, skip vendoring
                if nodeModulesInfo.ModTime().After(packageJsonInfo.ModTime()) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }

        <span class="cov0" title="0">return true, nil</span>
}

// PerformVendoringIfNeeded performs vendoring only if needed and Docker is available
func PerformVendoringIfNeeded(projectPath string) error <span class="cov0" title="0">{
        blue := color.New(color.FgBlue)
        red := color.New(color.FgRed)

        // Check if Python vendoring is needed
        shouldVendorPython, err := ShouldPerformVendoring(projectPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check if Node.js vendoring is needed
        <span class="cov0" title="0">shouldVendorNode, err := ShouldPerformNodeVendoring(projectPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !shouldVendorPython &amp;&amp; !shouldVendorNode </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Check Docker availability - fail hard if dependencies exist but Docker unavailable
        <span class="cov0" title="0">if err := CheckDockerInstalled(); err != nil </span><span class="cov0" title="0">{
                red.Printf("‚ö†Ô∏è Docker required for dependency installation: %v\n", err)
                red.Println("‚ö†Ô∏è Cannot deploy bot without installed dependencies")
                red.Println("üí° Solution: Install Docker and try again")
                return fmt.Errorf("docker unavailable but dependencies detected - installation required")
        }</span>

        <span class="cov0" title="0">vm, err := NewVendorManager(projectPath)
        if err != nil </span><span class="cov0" title="0">{
                red.Printf("‚ö†Ô∏è Failed to initialize dependency installer: %v\n", err)
                red.Println("‚ö†Ô∏è Cannot deploy bot without installed dependencies")
                return fmt.Errorf("vendor manager initialization failed: %v", err)
        }</span>
        <span class="cov0" title="0">defer vm.Close()

        if err := vm.CheckDockerRunning(); err != nil </span><span class="cov0" title="0">{
                red.Printf("‚ö†Ô∏è Docker daemon not running: %v\n", err)
                red.Println("‚ö†Ô∏è Cannot install dependencies without Docker")
                red.Println("üí° Solution: Start Docker daemon and try again")
                return fmt.Errorf("docker daemon not running but dependencies detected - installation required")
        }</span>

        // Perform Python vendoring if needed
        <span class="cov0" title="0">if shouldVendorPython </span><span class="cov0" title="0">{
                blue.Println("üêç Python dependencies detected - starting installation...")
                if err := vm.PerformVendoring(); err != nil </span><span class="cov0" title="0">{
                        red.Printf("‚ö†Ô∏è Python dependency installation failed: %v\n", err)
                        red.Println("‚ö†Ô∏è Cannot deploy bot without successfully compiled dependencies")
                        return fmt.Errorf("python vendoring failed: %v", err)
                }</span>
        }

        // Perform Node.js vendoring if needed
        <span class="cov0" title="0">if shouldVendorNode </span><span class="cov0" title="0">{
                blue.Println("‚ö° JavaScript dependencies detected - starting installation...")
                hasTypeScript := vm.CheckTypeScriptFiles()
                if err := vm.PerformNodeVendoring(hasTypeScript); err != nil </span><span class="cov0" title="0">{
                        red.Printf("‚ö†Ô∏è JavaScript dependency installation failed: %v\n", err)
                        red.Println("‚ö†Ô∏è Cannot deploy bot without successfully compiled dependencies")
                        return fmt.Errorf("node vendoring failed: %v", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// CleanupVendoring removes vendor directories and ZIP files
func CleanupVendoring(projectPath string) <span class="cov0" title="0">{
        // Remove vendor directory
        vendorPath := filepath.Join(projectPath, vendorDir)
        if _, err := os.Stat(vendorPath); err == nil </span><span class="cov0" title="0">{
                os.RemoveAll(vendorPath)
        }</span>

        // Remove node_modules directory
        <span class="cov0" title="0">nodeModulesPath := filepath.Join(projectPath, nodeModulesDir)
        if _, err := os.Stat(nodeModulesPath); err == nil </span><span class="cov0" title="0">{
                os.RemoveAll(nodeModulesPath)
        }</span>

        // Remove any bot ZIP files
        <span class="cov0" title="0">files, err := filepath.Glob(filepath.Join(projectPath, "bot_*.zip"))
        if err == nil </span><span class="cov0" title="0">{
                for _, file := range files </span><span class="cov0" title="0">{
                        os.Remove(file)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package internal

import (
        "fmt"
        "strings"

        "github.com/Masterminds/semver/v3"
)

// ParseVersion handles both production and develop version formats
// Production format: v2024.01.15-123 or 2024.01.15-123
// Development format: develop-2024.01.15-123
func ParseVersion(versionStr string) (*semver.Version, error) <span class="cov0" title="0">{
        // Clean version string
        cleaned := strings.TrimSpace(versionStr)

        // Handle develop versions: develop-2024.01.15-123 -&gt; 2024.01.15-123
        if strings.HasPrefix(cleaned, "develop-") </span><span class="cov0" title="0">{
                cleaned = strings.TrimPrefix(cleaned, "develop-")
        }</span> else<span class="cov0" title="0"> {
                // Handle production versions - ensure they start with 'v'
                if !strings.HasPrefix(cleaned, "v") </span><span class="cov0" title="0">{
                        cleaned = "v" + cleaned
                }</span>
        }

        <span class="cov0" title="0">return semver.NewVersion(cleaned)</span>
}

// CompareVersions compares two version strings and returns true if latest &gt; current
func CompareVersions(current, latest string) (bool, error) <span class="cov0" title="0">{
        currentVer, err := ParseVersion(current)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("invalid current version: %w", err)
        }</span>

        <span class="cov0" title="0">latestVer, err := ParseVersion(latest)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("invalid latest version: %w", err)
        }</span>

        <span class="cov0" title="0">return latestVer.GreaterThan(currentVer), nil</span>
}

// GetCurrentVersion extracts the current version from the VERSION constant
func GetCurrentVersion() string <span class="cov0" title="0">{
        // This will be imported from main package when needed
        // For now, we'll make it configurable
        return "1.0.0"
}</span>

// NormalizeVersion normalizes a version string for display
func NormalizeVersion(version string) string <span class="cov0" title="0">{
        cleaned := strings.TrimSpace(version)

        // If it's a develop version, show it as-is
        if strings.HasPrefix(cleaned, "develop-") </span><span class="cov0" title="0">{
                return cleaned
        }</span>

        // Remove 'v' prefix for display if present
        <span class="cov0" title="0">if strings.HasPrefix(cleaned, "v") </span><span class="cov0" title="0">{
                return strings.TrimPrefix(cleaned, "v")
        }</span>

        <span class="cov0" title="0">return cleaned</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package internal

import (
        "archive/zip"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
        "time"
)

// CreateBotZip creates a ZIP file containing all bot files from current directory
func CreateBotZip() (string, error) <span class="cov0" title="0">{
        return CreateBotZipFromDir(".")
}</span>

// CreateBotZip creates a ZIP file containing all bot files
func CreateBotZipFromDir(sourceDir string) (string, error) <span class="cov0" title="0">{
        zipPath := fmt.Sprintf("bot_%d.zip", time.Now().Unix())
        zipFile, err := os.Create(zipPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer zipFile.Close()

        zipWriter := zip.NewWriter(zipFile)
        defer zipWriter.Close()

        // Create ignore parser for the source directory
        ignoreParser, err := CreateIgnoreParserForDir(sourceDir)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create ignore parser: %v", err)
        }</span>

        <span class="cov0" title="0">err = filepath.Walk(sourceDir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Skip the zip file itself
                <span class="cov0" title="0">if filepath.Base(path) == zipPath </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Get relative path from source directory
                <span class="cov0" title="0">relPath, err := filepath.Rel(sourceDir, path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Skip if it's the source directory itself
                <span class="cov0" title="0">if relPath == "." </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Skip hidden files and directories
                <span class="cov0" title="0">if strings.HasPrefix(filepath.Base(path), ".") </span><span class="cov0" title="0">{
                        if info.IsDir() </span><span class="cov0" title="0">{
                                return filepath.SkipDir
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                // Check ignore patterns
                <span class="cov0" title="0">if ignoreParser.IsIgnored(relPath, info.IsDir()) </span><span class="cov0" title="0">{
                        if info.IsDir() </span><span class="cov0" title="0">{
                                return filepath.SkipDir
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">file, err := os.Open(path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer file.Close()

                // Use relative path in ZIP
                writer, err := zipWriter.Create(relPath)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">_, err = io.Copy(writer, file)
                return err</span>
        })

        <span class="cov0" title="0">return zipPath, err</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package main

import (
        "context"
        "fmt"
        "os"
        "time"

        "github.com/spf13/cobra"
        "the0/cmd"
        "the0/internal"
)

var (
        VERSION = "0.0.0-dev" // Default for development, overridden by CI via ldflags
)

func main() <span class="cov0" title="0">{
        // Set version for update commands
        cmd.SetVersion(VERSION)

        var rootCmd = &amp;cobra.Command{
                Use:   "the0",
                Short: "the0 CLI - Deploy and manage your trading bots",
                Long: `
 _____ _          ___  
|_   _| |_  ___  / _ \ 
  | | | ' \/ -_)| (_) |
  |_| |_||_\___| \___/ 
                       
the0 CLI - Terminal-based trading bot management`,
                Version: VERSION,
        }

        // Add command groups
        rootCmd.AddCommand(cmd.NewCustomBotCmd())
        rootCmd.AddCommand(cmd.NewBotCmd())
        rootCmd.AddCommand(cmd.NewBacktestCmd())
        rootCmd.AddCommand(cmd.NewAuthCmd())
        rootCmd.AddCommand(cmd.NewCheckUpdateCmd())
        rootCmd.AddCommand(cmd.NewSelfUpdateCmd())

        // Check for updates before executing commands
        // Skip if quiet mode or if we're running a help command
        if os.Getenv("THE0_QUIET") == "" &amp;&amp; !(len(os.Args) &gt; 1 &amp;&amp; (os.Args[1] == "help" || os.Args[1] == "--help" || os.Args[1] == "-h")) </span><span class="cov0" title="0">{
                // Skip if we're running update commands to avoid recursion
                if !(len(os.Args) &gt; 1 &amp;&amp; (os.Args[1] == "check-update" || os.Args[1] == "self-update")) </span><span class="cov0" title="0">{
                        updater := internal.NewUpdater(internal.UpdateConfig{
                                Channel:        internal.GetUpdateChannel(),
                                CurrentVersion: VERSION,
                                CheckTimeout:   2 * time.Second, // Fast timeout for startup
                        })

                        ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
                        defer cancel()

                        updateAvailable, latestVersion, err := updater.CheckForUpdates(ctx)
                        if err == nil &amp;&amp; updateAvailable </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "‚ö†Ô∏è  A new version of the0 CLI is available!\n")
                                fmt.Fprintf(os.Stderr, "   Current: %s\n", internal.NormalizeVersion(VERSION))
                                fmt.Fprintf(os.Stderr, "   Latest:  %s\n", internal.NormalizeVersion(latestVersion))
                                fmt.Fprintf(os.Stderr, "\n   Run 'the0 self-update' to update or 'the0 check-update --help' for options.\n\n")
                        }</span>
                }
        }

        <span class="cov0" title="0">if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
