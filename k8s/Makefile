# Makefile for the0 Kubernetes Deployment

.PHONY: help
help: ## Show this help message
	@echo "üöÄ the0 Platform - Kubernetes Deployment"
	@echo ""
	@awk 'BEGIN {FS = ":.*##"; printf "Usage:\n  make \033[36m<target>\033[0m\n\nTargets:\n"} /^[a-zA-Z_-]+:.*?##/ { printf "  \033[36m%-20s\033[0m %s\n", $$1, $$2 }' $(MAKEFILE_LIST)

# Variables
RELEASE_NAME ?= the0
NAMESPACE ?= the0
CHART_PATH ?= .

# Prerequisites check for general use
.PHONY: check-deps
check-deps: ## Check if required tools are installed and cluster is accessible
	@command -v helm >/dev/null 2>&1 || { echo "‚ùå Helm is required. Install: https://helm.sh/docs/intro/install/"; exit 1; }
	@command -v kubectl >/dev/null 2>&1 || { echo "‚ùå kubectl is required. Install: https://kubernetes.io/docs/tasks/tools/"; exit 1; }
	@kubectl cluster-info >/dev/null 2>&1 || { echo "‚ùå kubectl not configured or cluster unreachable"; exit 1; }
	@echo "‚úÖ Prerequisites satisfied"

# Prerequisites check for minikube (doesn't require running cluster)
.PHONY: check-minikube-deps
check-minikube-deps: ## Check if required tools are installed for minikube
	@command -v minikube >/dev/null 2>&1 || { echo "‚ùå Minikube is required. Install: https://minikube.sigs.k8s.io/docs/start/"; exit 1; }
	@command -v helm >/dev/null 2>&1 || { echo "‚ùå Helm is required. Install: https://helm.sh/docs/intro/install/"; exit 1; }
	@command -v kubectl >/dev/null 2>&1 || { echo "‚ùå kubectl is required. Install: https://kubernetes.io/docs/tasks/tools/"; exit 1; }
	@command -v docker >/dev/null 2>&1 || { echo "‚ùå Docker is required. Install: https://docs.docker.com/get-docker/"; exit 1; }
	@echo "‚úÖ Minikube prerequisites satisfied"


# Minikube lifecycle management
.PHONY: minikube-up
minikube-up: check-minikube-deps ## Build, deploy and show service URLs (simplified)
	@echo "üèóÔ∏è  Starting minikube deployment..."
	@minikube start --memory=4096 --cpus=4 --disk-size=20g --driver=docker 2>/dev/null || echo "Minikube already running"
	@echo "‚è≥ Waiting for minikube cluster to be ready..."
	@kubectl cluster-info >/dev/null 2>&1 || { echo "‚ùå Failed to connect to minikube cluster"; exit 1; }
	@echo "‚úÖ Minikube cluster is ready"
	@echo "üî® Building application images in minikube environment..."
	@echo "‚ö†Ô∏è  Note: This requires internet connectivity to pull base images from Docker Hub"
	@eval $$(minikube docker-env) && \
		docker build -t the0-api:latest ../api && \
		docker build --build-arg NEXT_PUBLIC_API_URL=http://api.the0.local:30000 -t the0-frontend:latest ../frontend && \
		docker build -t runtime:latest ../runtime && \
		docker build -t the0-analyzer:latest ../services/0vers33r
	@echo "üöÄ Deploying to minikube..."
	@kubectl create namespace $(NAMESPACE) --dry-run=client -o yaml | kubectl apply -f -
	@helm upgrade --install $(RELEASE_NAME) $(CHART_PATH) \
		--namespace $(NAMESPACE) \
		--set global.imagePullPolicy=IfNotPresent \
		--set the0Api.imagePullPolicy=Never \
		--set the0Frontend.imagePullPolicy=Never \
		--set botRunner.imagePullPolicy=Never \
		--set backtestRunner.imagePullPolicy=Never \
		--set botScheduler.imagePullPolicy=Never \
		--set the0Analyzer.imagePullPolicy=Never \
		--set minikube.enabled=true \
		--set externalServices.enabled=true
	@echo ""
	@echo "‚úÖ Deployment completed! Services will be available once pods are ready."
	@echo ""
	@echo "üåê NodePort URLs (no tunnel required):"
	@echo "   Frontend:  http://the0.local:30001"
	@echo "   API:       http://api.the0.local:30000"
	@echo "   MinIO:     http://minio.the0.local:30002"
	@echo ""
	@echo "‚ö†Ô∏è  To access services:"
	@echo "   1. Run: make setup-hosts"
	@echo "   2. That's it! No tunnel needed."
	@echo ""
	@echo "üí° Use 'make status' to check pod readiness"
	@echo "üí° Use 'make logs' to view service logs"

.PHONY: minikube-down
minikube-down: ## Stop and remove deployment
	@echo "üõë Stopping minikube deployment..."
	@if minikube status >/dev/null 2>&1; then \
		helm uninstall $(RELEASE_NAME) -n $(NAMESPACE) 2>/dev/null || echo "Release not found"; \
		kubectl delete namespace $(NAMESPACE) --ignore-not-found=true; \
		echo "‚úÖ Minikube deployment stopped and cleaned up"; \
	else \
		echo "‚ö†Ô∏è  Minikube is not running"; \
	fi

.PHONY: minikube-pause
minikube-pause: ## Pause minikube (saves resources, preserves environment)
	@echo "‚è∏Ô∏è  Pausing minikube..."
	@minikube pause
	@echo "‚úÖ Minikube paused. Use 'make minikube-resume' to resume."

.PHONY: minikube-resume
minikube-resume: ## Resume paused minikube
	@echo "‚ñ∂Ô∏è  Resuming minikube..."
	@minikube unpause
	@echo "‚úÖ Minikube resumed."

.PHONY: minikube-stop
minikube-stop: ## Stop minikube (preserves cluster, saves more resources)
	@echo "üõë Stopping minikube..."
	@minikube stop
	@echo "‚úÖ Minikube stopped. Use 'make minikube-start' to restart."

.PHONY: minikube-start
minikube-start: ## Start stopped minikube
	@echo "üöÄ Starting minikube..."
	@minikube start
	@echo "‚úÖ Minikube started."

.PHONY: minikube-restart
minikube-restart: minikube-down minikube-up ## Quick restart (rebuild and redeploy)


.PHONY: minikube
minikube: minikube-up ## Alias for minikube-up (backward compatibility)

.PHONY: setup-hosts
setup-hosts: ## Add the0.local hostnames to /etc/hosts
	@echo "üîß Setting up /etc/hosts entries..."
	@MINIKUBE_IP=$$(minikube ip) && \
	if grep -q "the0.local" /etc/hosts; then \
		echo "‚ö†Ô∏è  Updating existing the0.local entries in /etc/hosts"; \
		sudo sed -i '/the0\.local/d' /etc/hosts; \
	fi && \
	echo "$$MINIKUBE_IP  the0.local api.the0.local minio.the0.local" | sudo tee -a /etc/hosts > /dev/null && \
	echo "‚úÖ Added the0.local entries to /etc/hosts ($$MINIKUBE_IP)"

.PHONY: tunnel
tunnel: ## Start minikube tunnel for LoadBalancer services
	@echo "üîÑ Starting minikube tunnel..."
	@minikube tunnel

.PHONY: remove-hosts
remove-hosts: ## Remove the0.local hostnames from /etc/hosts
	@echo "üîß Removing /etc/hosts entries..."
	@sudo sed -i '/the0\.local/d' /etc/hosts
	@echo "‚úÖ Removed the0.local entries from /etc/hosts"

# Production deployment (assumes external infrastructure)
.PHONY: deploy
deploy: check-deps ## Deploy to production cluster with external infrastructure
	@echo "üöÄ Deploying to production cluster..."
	@kubectl create namespace $(NAMESPACE) --dry-run=client -o yaml | kubectl apply -f -
	@helm upgrade --install $(RELEASE_NAME) $(CHART_PATH) \
		--namespace $(NAMESPACE) \
		--set postgresql.enabled=false \
		--set mongodb.enabled=false \
		--set nats.enabled=false \
		--set minio.enabled=false \
		--set minikube.enabled=false
	@echo "‚úÖ Production deployment completed!"

# Status and logs
.PHONY: status
status: check-deps ## Show deployment status
	@helm status $(RELEASE_NAME) -n $(NAMESPACE)
	@echo ""
	@kubectl get pods -n $(NAMESPACE)

.PHONY: logs
logs: check-deps ## Show recent logs from all services
	@kubectl logs -n $(NAMESPACE) -l app.kubernetes.io/instance=$(RELEASE_NAME) --tail=50 --all-containers=true

# Show minikube service URLs
define show_services
	@echo "‚úÖ Services available via minikube:"
	@echo ""
	@minikube service list -n $(NAMESPACE)
	@echo ""
	@echo "üéØ LoadBalancer services accessible on localhost via minikube tunnel"
endef

# Minikube service access
.PHONY: urls
urls: check-deps ## Show minikube service URLs
	@echo "üìç Minikube service URLs:"
	@minikube service list -n $(NAMESPACE) | grep $(RELEASE_NAME)-.*-external || echo "No external services found"

.PHONY: services 
services: check-deps ## Show minikube service URLs
	$(call show_services)


# Cleanup
.PHONY: uninstall
uninstall: check-deps ## Remove the deployment
	@helm uninstall $(RELEASE_NAME) -n $(NAMESPACE)
	@echo "‚úÖ Deployment removed"

.PHONY: clean
clean: uninstall ## Remove deployment and namespace
	@kubectl delete namespace $(NAMESPACE) --ignore-not-found=true
	@echo "‚úÖ Namespace removed"

# Default target
.DEFAULT_GOAL := help